module.exports = {

"[project]/node_modules/mermaid/dist/styles-6aaf32cf.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "D": (()=>DEFAULT_STATE_TYPE),
    "S": (()=>STMT_RELATION),
    "a": (()=>DIVIDER_TYPE),
    "b": (()=>STMT_STATE),
    "c": (()=>DEFAULT_NESTED_DOC_DIR),
    "d": (()=>db),
    "p": (()=>parser$1),
    "s": (()=>styles)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/mermaid-b5860b54.js [app-ssr] (ecmascript)");
;
var parser = function() {
    var o = function(k, v, o2, l) {
        for(o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v);
        return o2;
    }, $V0 = [
        1,
        2
    ], $V1 = [
        1,
        3
    ], $V2 = [
        1,
        4
    ], $V3 = [
        2,
        4
    ], $V4 = [
        1,
        9
    ], $V5 = [
        1,
        11
    ], $V6 = [
        1,
        15
    ], $V7 = [
        1,
        16
    ], $V8 = [
        1,
        17
    ], $V9 = [
        1,
        18
    ], $Va = [
        1,
        30
    ], $Vb = [
        1,
        19
    ], $Vc = [
        1,
        20
    ], $Vd = [
        1,
        21
    ], $Ve = [
        1,
        22
    ], $Vf = [
        1,
        23
    ], $Vg = [
        1,
        25
    ], $Vh = [
        1,
        26
    ], $Vi = [
        1,
        27
    ], $Vj = [
        1,
        28
    ], $Vk = [
        1,
        29
    ], $Vl = [
        1,
        32
    ], $Vm = [
        1,
        33
    ], $Vn = [
        1,
        34
    ], $Vo = [
        1,
        35
    ], $Vp = [
        1,
        31
    ], $Vq = [
        1,
        4,
        5,
        15,
        16,
        18,
        20,
        21,
        23,
        24,
        25,
        26,
        27,
        28,
        32,
        34,
        36,
        37,
        41,
        44,
        45,
        46,
        47,
        50
    ], $Vr = [
        1,
        4,
        5,
        13,
        14,
        15,
        16,
        18,
        20,
        21,
        23,
        24,
        25,
        26,
        27,
        28,
        32,
        34,
        36,
        37,
        41,
        44,
        45,
        46,
        47,
        50
    ], $Vs = [
        4,
        5,
        15,
        16,
        18,
        20,
        21,
        23,
        24,
        25,
        26,
        27,
        28,
        32,
        34,
        36,
        37,
        41,
        44,
        45,
        46,
        47,
        50
    ];
    var parser2 = {
        trace: function trace() {},
        yy: {},
        symbols_: {
            "error": 2,
            "start": 3,
            "SPACE": 4,
            "NL": 5,
            "SD": 6,
            "document": 7,
            "line": 8,
            "statement": 9,
            "classDefStatement": 10,
            "cssClassStatement": 11,
            "idStatement": 12,
            "DESCR": 13,
            "-->": 14,
            "HIDE_EMPTY": 15,
            "scale": 16,
            "WIDTH": 17,
            "COMPOSIT_STATE": 18,
            "STRUCT_START": 19,
            "STRUCT_STOP": 20,
            "STATE_DESCR": 21,
            "AS": 22,
            "ID": 23,
            "FORK": 24,
            "JOIN": 25,
            "CHOICE": 26,
            "CONCURRENT": 27,
            "note": 28,
            "notePosition": 29,
            "NOTE_TEXT": 30,
            "direction": 31,
            "acc_title": 32,
            "acc_title_value": 33,
            "acc_descr": 34,
            "acc_descr_value": 35,
            "acc_descr_multiline_value": 36,
            "classDef": 37,
            "CLASSDEF_ID": 38,
            "CLASSDEF_STYLEOPTS": 39,
            "DEFAULT": 40,
            "class": 41,
            "CLASSENTITY_IDS": 42,
            "STYLECLASS": 43,
            "direction_tb": 44,
            "direction_bt": 45,
            "direction_rl": 46,
            "direction_lr": 47,
            "eol": 48,
            ";": 49,
            "EDGE_STATE": 50,
            "STYLE_SEPARATOR": 51,
            "left_of": 52,
            "right_of": 53,
            "$accept": 0,
            "$end": 1
        },
        terminals_: {
            2: "error",
            4: "SPACE",
            5: "NL",
            6: "SD",
            13: "DESCR",
            14: "-->",
            15: "HIDE_EMPTY",
            16: "scale",
            17: "WIDTH",
            18: "COMPOSIT_STATE",
            19: "STRUCT_START",
            20: "STRUCT_STOP",
            21: "STATE_DESCR",
            22: "AS",
            23: "ID",
            24: "FORK",
            25: "JOIN",
            26: "CHOICE",
            27: "CONCURRENT",
            28: "note",
            30: "NOTE_TEXT",
            32: "acc_title",
            33: "acc_title_value",
            34: "acc_descr",
            35: "acc_descr_value",
            36: "acc_descr_multiline_value",
            37: "classDef",
            38: "CLASSDEF_ID",
            39: "CLASSDEF_STYLEOPTS",
            40: "DEFAULT",
            41: "class",
            42: "CLASSENTITY_IDS",
            43: "STYLECLASS",
            44: "direction_tb",
            45: "direction_bt",
            46: "direction_rl",
            47: "direction_lr",
            49: ";",
            50: "EDGE_STATE",
            51: "STYLE_SEPARATOR",
            52: "left_of",
            53: "right_of"
        },
        productions_: [
            0,
            [
                3,
                2
            ],
            [
                3,
                2
            ],
            [
                3,
                2
            ],
            [
                7,
                0
            ],
            [
                7,
                2
            ],
            [
                8,
                2
            ],
            [
                8,
                1
            ],
            [
                8,
                1
            ],
            [
                9,
                1
            ],
            [
                9,
                1
            ],
            [
                9,
                1
            ],
            [
                9,
                2
            ],
            [
                9,
                3
            ],
            [
                9,
                4
            ],
            [
                9,
                1
            ],
            [
                9,
                2
            ],
            [
                9,
                1
            ],
            [
                9,
                4
            ],
            [
                9,
                3
            ],
            [
                9,
                6
            ],
            [
                9,
                1
            ],
            [
                9,
                1
            ],
            [
                9,
                1
            ],
            [
                9,
                1
            ],
            [
                9,
                4
            ],
            [
                9,
                4
            ],
            [
                9,
                1
            ],
            [
                9,
                2
            ],
            [
                9,
                2
            ],
            [
                9,
                1
            ],
            [
                10,
                3
            ],
            [
                10,
                3
            ],
            [
                11,
                3
            ],
            [
                31,
                1
            ],
            [
                31,
                1
            ],
            [
                31,
                1
            ],
            [
                31,
                1
            ],
            [
                48,
                1
            ],
            [
                48,
                1
            ],
            [
                12,
                1
            ],
            [
                12,
                1
            ],
            [
                12,
                3
            ],
            [
                12,
                3
            ],
            [
                29,
                1
            ],
            [
                29,
                1
            ]
        ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch(yystate){
                case 3:
                    yy.setRootDoc($$[$0]);
                    return $$[$0];
                case 4:
                    this.$ = [];
                    break;
                case 5:
                    if ($$[$0] != "nl") {
                        $$[$0 - 1].push($$[$0]);
                        this.$ = $$[$0 - 1];
                    }
                    break;
                case 6:
                case 7:
                    this.$ = $$[$0];
                    break;
                case 8:
                    this.$ = "nl";
                    break;
                case 11:
                    this.$ = $$[$0];
                    break;
                case 12:
                    const stateStmt = $$[$0 - 1];
                    stateStmt.description = yy.trimColon($$[$0]);
                    this.$ = stateStmt;
                    break;
                case 13:
                    this.$ = {
                        stmt: "relation",
                        state1: $$[$0 - 2],
                        state2: $$[$0]
                    };
                    break;
                case 14:
                    const relDescription = yy.trimColon($$[$0]);
                    this.$ = {
                        stmt: "relation",
                        state1: $$[$0 - 3],
                        state2: $$[$0 - 1],
                        description: relDescription
                    };
                    break;
                case 18:
                    this.$ = {
                        stmt: "state",
                        id: $$[$0 - 3],
                        type: "default",
                        description: "",
                        doc: $$[$0 - 1]
                    };
                    break;
                case 19:
                    var id = $$[$0];
                    var description = $$[$0 - 2].trim();
                    if ($$[$0].match(":")) {
                        var parts = $$[$0].split(":");
                        id = parts[0];
                        description = [
                            description,
                            parts[1]
                        ];
                    }
                    this.$ = {
                        stmt: "state",
                        id,
                        type: "default",
                        description
                    };
                    break;
                case 20:
                    this.$ = {
                        stmt: "state",
                        id: $$[$0 - 3],
                        type: "default",
                        description: $$[$0 - 5],
                        doc: $$[$0 - 1]
                    };
                    break;
                case 21:
                    this.$ = {
                        stmt: "state",
                        id: $$[$0],
                        type: "fork"
                    };
                    break;
                case 22:
                    this.$ = {
                        stmt: "state",
                        id: $$[$0],
                        type: "join"
                    };
                    break;
                case 23:
                    this.$ = {
                        stmt: "state",
                        id: $$[$0],
                        type: "choice"
                    };
                    break;
                case 24:
                    this.$ = {
                        stmt: "state",
                        id: yy.getDividerId(),
                        type: "divider"
                    };
                    break;
                case 25:
                    this.$ = {
                        stmt: "state",
                        id: $$[$0 - 1].trim(),
                        note: {
                            position: $$[$0 - 2].trim(),
                            text: $$[$0].trim()
                        }
                    };
                    break;
                case 28:
                    this.$ = $$[$0].trim();
                    yy.setAccTitle(this.$);
                    break;
                case 29:
                case 30:
                    this.$ = $$[$0].trim();
                    yy.setAccDescription(this.$);
                    break;
                case 31:
                case 32:
                    this.$ = {
                        stmt: "classDef",
                        id: $$[$0 - 1].trim(),
                        classes: $$[$0].trim()
                    };
                    break;
                case 33:
                    this.$ = {
                        stmt: "applyClass",
                        id: $$[$0 - 1].trim(),
                        styleClass: $$[$0].trim()
                    };
                    break;
                case 34:
                    yy.setDirection("TB");
                    this.$ = {
                        stmt: "dir",
                        value: "TB"
                    };
                    break;
                case 35:
                    yy.setDirection("BT");
                    this.$ = {
                        stmt: "dir",
                        value: "BT"
                    };
                    break;
                case 36:
                    yy.setDirection("RL");
                    this.$ = {
                        stmt: "dir",
                        value: "RL"
                    };
                    break;
                case 37:
                    yy.setDirection("LR");
                    this.$ = {
                        stmt: "dir",
                        value: "LR"
                    };
                    break;
                case 40:
                case 41:
                    this.$ = {
                        stmt: "state",
                        id: $$[$0].trim(),
                        type: "default",
                        description: ""
                    };
                    break;
                case 42:
                    this.$ = {
                        stmt: "state",
                        id: $$[$0 - 2].trim(),
                        classes: [
                            $$[$0].trim()
                        ],
                        type: "default",
                        description: ""
                    };
                    break;
                case 43:
                    this.$ = {
                        stmt: "state",
                        id: $$[$0 - 2].trim(),
                        classes: [
                            $$[$0].trim()
                        ],
                        type: "default",
                        description: ""
                    };
                    break;
            }
        },
        table: [
            {
                3: 1,
                4: $V0,
                5: $V1,
                6: $V2
            },
            {
                1: [
                    3
                ]
            },
            {
                3: 5,
                4: $V0,
                5: $V1,
                6: $V2
            },
            {
                3: 6,
                4: $V0,
                5: $V1,
                6: $V2
            },
            o([
                1,
                4,
                5,
                15,
                16,
                18,
                21,
                23,
                24,
                25,
                26,
                27,
                28,
                32,
                34,
                36,
                37,
                41,
                44,
                45,
                46,
                47,
                50
            ], $V3, {
                7: 7
            }),
            {
                1: [
                    2,
                    1
                ]
            },
            {
                1: [
                    2,
                    2
                ]
            },
            {
                1: [
                    2,
                    3
                ],
                4: $V4,
                5: $V5,
                8: 8,
                9: 10,
                10: 12,
                11: 13,
                12: 14,
                15: $V6,
                16: $V7,
                18: $V8,
                21: $V9,
                23: $Va,
                24: $Vb,
                25: $Vc,
                26: $Vd,
                27: $Ve,
                28: $Vf,
                31: 24,
                32: $Vg,
                34: $Vh,
                36: $Vi,
                37: $Vj,
                41: $Vk,
                44: $Vl,
                45: $Vm,
                46: $Vn,
                47: $Vo,
                50: $Vp
            },
            o($Vq, [
                2,
                5
            ]),
            {
                9: 36,
                10: 12,
                11: 13,
                12: 14,
                15: $V6,
                16: $V7,
                18: $V8,
                21: $V9,
                23: $Va,
                24: $Vb,
                25: $Vc,
                26: $Vd,
                27: $Ve,
                28: $Vf,
                31: 24,
                32: $Vg,
                34: $Vh,
                36: $Vi,
                37: $Vj,
                41: $Vk,
                44: $Vl,
                45: $Vm,
                46: $Vn,
                47: $Vo,
                50: $Vp
            },
            o($Vq, [
                2,
                7
            ]),
            o($Vq, [
                2,
                8
            ]),
            o($Vq, [
                2,
                9
            ]),
            o($Vq, [
                2,
                10
            ]),
            o($Vq, [
                2,
                11
            ], {
                13: [
                    1,
                    37
                ],
                14: [
                    1,
                    38
                ]
            }),
            o($Vq, [
                2,
                15
            ]),
            {
                17: [
                    1,
                    39
                ]
            },
            o($Vq, [
                2,
                17
            ], {
                19: [
                    1,
                    40
                ]
            }),
            {
                22: [
                    1,
                    41
                ]
            },
            o($Vq, [
                2,
                21
            ]),
            o($Vq, [
                2,
                22
            ]),
            o($Vq, [
                2,
                23
            ]),
            o($Vq, [
                2,
                24
            ]),
            {
                29: 42,
                30: [
                    1,
                    43
                ],
                52: [
                    1,
                    44
                ],
                53: [
                    1,
                    45
                ]
            },
            o($Vq, [
                2,
                27
            ]),
            {
                33: [
                    1,
                    46
                ]
            },
            {
                35: [
                    1,
                    47
                ]
            },
            o($Vq, [
                2,
                30
            ]),
            {
                38: [
                    1,
                    48
                ],
                40: [
                    1,
                    49
                ]
            },
            {
                42: [
                    1,
                    50
                ]
            },
            o($Vr, [
                2,
                40
            ], {
                51: [
                    1,
                    51
                ]
            }),
            o($Vr, [
                2,
                41
            ], {
                51: [
                    1,
                    52
                ]
            }),
            o($Vq, [
                2,
                34
            ]),
            o($Vq, [
                2,
                35
            ]),
            o($Vq, [
                2,
                36
            ]),
            o($Vq, [
                2,
                37
            ]),
            o($Vq, [
                2,
                6
            ]),
            o($Vq, [
                2,
                12
            ]),
            {
                12: 53,
                23: $Va,
                50: $Vp
            },
            o($Vq, [
                2,
                16
            ]),
            o($Vs, $V3, {
                7: 54
            }),
            {
                23: [
                    1,
                    55
                ]
            },
            {
                23: [
                    1,
                    56
                ]
            },
            {
                22: [
                    1,
                    57
                ]
            },
            {
                23: [
                    2,
                    44
                ]
            },
            {
                23: [
                    2,
                    45
                ]
            },
            o($Vq, [
                2,
                28
            ]),
            o($Vq, [
                2,
                29
            ]),
            {
                39: [
                    1,
                    58
                ]
            },
            {
                39: [
                    1,
                    59
                ]
            },
            {
                43: [
                    1,
                    60
                ]
            },
            {
                23: [
                    1,
                    61
                ]
            },
            {
                23: [
                    1,
                    62
                ]
            },
            o($Vq, [
                2,
                13
            ], {
                13: [
                    1,
                    63
                ]
            }),
            {
                4: $V4,
                5: $V5,
                8: 8,
                9: 10,
                10: 12,
                11: 13,
                12: 14,
                15: $V6,
                16: $V7,
                18: $V8,
                20: [
                    1,
                    64
                ],
                21: $V9,
                23: $Va,
                24: $Vb,
                25: $Vc,
                26: $Vd,
                27: $Ve,
                28: $Vf,
                31: 24,
                32: $Vg,
                34: $Vh,
                36: $Vi,
                37: $Vj,
                41: $Vk,
                44: $Vl,
                45: $Vm,
                46: $Vn,
                47: $Vo,
                50: $Vp
            },
            o($Vq, [
                2,
                19
            ], {
                19: [
                    1,
                    65
                ]
            }),
            {
                30: [
                    1,
                    66
                ]
            },
            {
                23: [
                    1,
                    67
                ]
            },
            o($Vq, [
                2,
                31
            ]),
            o($Vq, [
                2,
                32
            ]),
            o($Vq, [
                2,
                33
            ]),
            o($Vr, [
                2,
                42
            ]),
            o($Vr, [
                2,
                43
            ]),
            o($Vq, [
                2,
                14
            ]),
            o($Vq, [
                2,
                18
            ]),
            o($Vs, $V3, {
                7: 68
            }),
            o($Vq, [
                2,
                25
            ]),
            o($Vq, [
                2,
                26
            ]),
            {
                4: $V4,
                5: $V5,
                8: 8,
                9: 10,
                10: 12,
                11: 13,
                12: 14,
                15: $V6,
                16: $V7,
                18: $V8,
                20: [
                    1,
                    69
                ],
                21: $V9,
                23: $Va,
                24: $Vb,
                25: $Vc,
                26: $Vd,
                27: $Ve,
                28: $Vf,
                31: 24,
                32: $Vg,
                34: $Vh,
                36: $Vi,
                37: $Vj,
                41: $Vk,
                44: $Vl,
                45: $Vm,
                46: $Vn,
                47: $Vo,
                50: $Vp
            },
            o($Vq, [
                2,
                20
            ])
        ],
        defaultActions: {
            5: [
                2,
                1
            ],
            6: [
                2,
                2
            ],
            44: [
                2,
                44
            ],
            45: [
                2,
                45
            ]
        },
        parseError: function parseError(str, hash) {
            if (hash.recoverable) {
                this.trace(str);
            } else {
                var error = new Error(str);
                error.hash = hash;
                throw error;
            }
        },
        parse: function parse(input) {
            var self = this, stack = [
                0
            ], tstack = [], vstack = [
                null
            ], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
            var args = lstack.slice.call(arguments, 1);
            var lexer2 = Object.create(this.lexer);
            var sharedState = {
                yy: {}
            };
            for(var k in this.yy){
                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                    sharedState.yy[k] = this.yy[k];
                }
            }
            lexer2.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer2;
            sharedState.yy.parser = this;
            if (typeof lexer2.yylloc == "undefined") {
                lexer2.yylloc = {};
            }
            var yyloc = lexer2.yylloc;
            lstack.push(yyloc);
            var ranges = lexer2.options && lexer2.options.ranges;
            if (typeof sharedState.yy.parseError === "function") {
                this.parseError = sharedState.yy.parseError;
            } else {
                this.parseError = Object.getPrototypeOf(this).parseError;
            }
            function lex() {
                var token;
                token = tstack.pop() || lexer2.lex() || EOF;
                if (typeof token !== "number") {
                    if (token instanceof Array) {
                        tstack = token;
                        token = tstack.pop();
                    }
                    token = self.symbols_[token] || token;
                }
                return token;
            }
            var symbol, state, action, r, yyval = {}, p, len, newState, expected;
            while(true){
                state = stack[stack.length - 1];
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == "undefined") {
                        symbol = lex();
                    }
                    action = table[state] && table[state][symbol];
                }
                if (typeof action === "undefined" || !action.length || !action[0]) {
                    var errStr = "";
                    expected = [];
                    for(p in table[state]){
                        if (this.terminals_[p] && p > TERROR) {
                            expected.push("'" + this.terminals_[p] + "'");
                        }
                    }
                    if (lexer2.showPosition) {
                        errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                    } else {
                        errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                    }
                    this.parseError(errStr, {
                        text: lexer2.match,
                        token: this.terminals_[symbol] || symbol,
                        line: lexer2.yylineno,
                        loc: yyloc,
                        expected
                    });
                }
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                }
                switch(action[0]){
                    case 1:
                        stack.push(symbol);
                        vstack.push(lexer2.yytext);
                        lstack.push(lexer2.yylloc);
                        stack.push(action[1]);
                        symbol = null;
                        {
                            yyleng = lexer2.yyleng;
                            yytext = lexer2.yytext;
                            yylineno = lexer2.yylineno;
                            yyloc = lexer2.yylloc;
                        }
                        break;
                    case 2:
                        len = this.productions_[action[1]][1];
                        yyval.$ = vstack[vstack.length - len];
                        yyval._$ = {
                            first_line: lstack[lstack.length - (len || 1)].first_line,
                            last_line: lstack[lstack.length - 1].last_line,
                            first_column: lstack[lstack.length - (len || 1)].first_column,
                            last_column: lstack[lstack.length - 1].last_column
                        };
                        if (ranges) {
                            yyval._$.range = [
                                lstack[lstack.length - (len || 1)].range[0],
                                lstack[lstack.length - 1].range[1]
                            ];
                        }
                        r = this.performAction.apply(yyval, [
                            yytext,
                            yyleng,
                            yylineno,
                            sharedState.yy,
                            action[1],
                            vstack,
                            lstack
                        ].concat(args));
                        if (typeof r !== "undefined") {
                            return r;
                        }
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }
                        stack.push(this.productions_[action[1]][0]);
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;
                    case 3:
                        return true;
                }
            }
            return true;
        }
    };
    var lexer = function() {
        var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },
            // resets the lexer, sets new input
            setInput: function(input, yy) {
                this.yy = yy || this.yy || {};
                this._input = input;
                this._more = this._backtrack = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = "";
                this.conditionStack = [
                    "INITIAL"
                ];
                this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                };
                if (this.options.ranges) {
                    this.yylloc.range = [
                        0,
                        0
                    ];
                }
                this.offset = 0;
                return this;
            },
            // consumes and returns one char from the input
            input: function() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) {
                    this.yylloc.range[1]++;
                }
                this._input = this._input.slice(1);
                return ch;
            },
            // unshifts one char (or a string) into the input
            unput: function(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);
                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len);
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);
                if (lines.length - 1) {
                    this.yylineno -= lines.length - 1;
                }
                var r = this.yylloc.range;
                this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };
                if (this.options.ranges) {
                    this.yylloc.range = [
                        r[0],
                        r[0] + this.yyleng - len
                    ];
                }
                this.yyleng = this.yytext.length;
                return this;
            },
            // When called from action, caches matched text and appends it on next action
            more: function() {
                this._more = true;
                return this;
            },
            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function() {
                if (this.options.backtrack_lexer) {
                    this._backtrack = true;
                } else {
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
                return this;
            },
            // retain first n characters of the match
            less: function(n) {
                this.unput(this.match.slice(n));
            },
            // displays already matched input, i.e. for error messages
            pastInput: function() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            // displays upcoming input, i.e. for error messages
            upcomingInput: function() {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },
            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function(match, indexed_rule) {
                var token, lines, backup;
                if (this.options.backtrack_lexer) {
                    backup = {
                        yylineno: this.yylineno,
                        yylloc: {
                            first_line: this.yylloc.first_line,
                            last_line: this.last_line,
                            first_column: this.yylloc.first_column,
                            last_column: this.yylloc.last_column
                        },
                        yytext: this.yytext,
                        match: this.match,
                        matches: this.matches,
                        matched: this.matched,
                        yyleng: this.yyleng,
                        offset: this.offset,
                        _more: this._more,
                        _input: this._input,
                        yy: this.yy,
                        conditionStack: this.conditionStack.slice(0),
                        done: this.done
                    };
                    if (this.options.ranges) {
                        backup.yylloc.range = this.yylloc.range.slice(0);
                    }
                }
                lines = match[0].match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno += lines.length;
                }
                this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                };
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                    this.yylloc.range = [
                        this.offset,
                        this.offset += this.yyleng
                    ];
                }
                this._more = false;
                this._backtrack = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input) {
                    this.done = false;
                }
                if (token) {
                    return token;
                } else if (this._backtrack) {
                    for(var k in backup){
                        this[k] = backup[k];
                    }
                    return false;
                }
                return false;
            },
            // return next match in input
            next: function() {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) {
                    this.done = true;
                }
                var token, match, tempMatch, index;
                if (!this._more) {
                    this.yytext = "";
                    this.match = "";
                }
                var rules = this._currentRules();
                for(var i = 0; i < rules.length; i++){
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (this.options.backtrack_lexer) {
                            token = this.test_match(tempMatch, rules[i]);
                            if (token !== false) {
                                return token;
                            } else if (this._backtrack) {
                                match = false;
                                continue;
                            } else {
                                return false;
                            }
                        } else if (!this.options.flex) {
                            break;
                        }
                    }
                }
                if (match) {
                    token = this.test_match(match, rules[index]);
                    if (token !== false) {
                        return token;
                    }
                    return false;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
            },
            // return next match that has a token
            lex: function lex() {
                var r = this.next();
                if (r) {
                    return r;
                } else {
                    return this.lex();
                }
            },
            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },
            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
                var n = this.conditionStack.length - 1;
                if (n > 0) {
                    return this.conditionStack.pop();
                } else {
                    return this.conditionStack[0];
                }
            },
            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                } else {
                    return this.conditions["INITIAL"].rules;
                }
            },
            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
                n = this.conditionStack.length - 1 - Math.abs(n || 0);
                if (n >= 0) {
                    return this.conditionStack[n];
                } else {
                    return "INITIAL";
                }
            },
            // alias for begin(condition)
            pushState: function pushState(condition) {
                this.begin(condition);
            },
            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
                return this.conditionStack.length;
            },
            options: {
                "case-insensitive": true
            },
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                switch($avoiding_name_collisions){
                    case 0:
                        return 40;
                    case 1:
                        return 44;
                    case 2:
                        return 45;
                    case 3:
                        return 46;
                    case 4:
                        return 47;
                    case 5:
                        break;
                    case 6:
                        break;
                    case 7:
                        return 5;
                    case 8:
                        break;
                    case 9:
                        break;
                    case 10:
                        break;
                    case 11:
                        break;
                    case 12:
                        this.pushState("SCALE");
                        return 16;
                    case 13:
                        return 17;
                    case 14:
                        this.popState();
                        break;
                    case 15:
                        this.begin("acc_title");
                        return 32;
                    case 16:
                        this.popState();
                        return "acc_title_value";
                    case 17:
                        this.begin("acc_descr");
                        return 34;
                    case 18:
                        this.popState();
                        return "acc_descr_value";
                    case 19:
                        this.begin("acc_descr_multiline");
                        break;
                    case 20:
                        this.popState();
                        break;
                    case 21:
                        return "acc_descr_multiline_value";
                    case 22:
                        this.pushState("CLASSDEF");
                        return 37;
                    case 23:
                        this.popState();
                        this.pushState("CLASSDEFID");
                        return "DEFAULT_CLASSDEF_ID";
                    case 24:
                        this.popState();
                        this.pushState("CLASSDEFID");
                        return 38;
                    case 25:
                        this.popState();
                        return 39;
                    case 26:
                        this.pushState("CLASS");
                        return 41;
                    case 27:
                        this.popState();
                        this.pushState("CLASS_STYLE");
                        return 42;
                    case 28:
                        this.popState();
                        return 43;
                    case 29:
                        this.pushState("SCALE");
                        return 16;
                    case 30:
                        return 17;
                    case 31:
                        this.popState();
                        break;
                    case 32:
                        this.pushState("STATE");
                        break;
                    case 33:
                        this.popState();
                        yy_.yytext = yy_.yytext.slice(0, -8).trim();
                        return 24;
                    case 34:
                        this.popState();
                        yy_.yytext = yy_.yytext.slice(0, -8).trim();
                        return 25;
                    case 35:
                        this.popState();
                        yy_.yytext = yy_.yytext.slice(0, -10).trim();
                        return 26;
                    case 36:
                        this.popState();
                        yy_.yytext = yy_.yytext.slice(0, -8).trim();
                        return 24;
                    case 37:
                        this.popState();
                        yy_.yytext = yy_.yytext.slice(0, -8).trim();
                        return 25;
                    case 38:
                        this.popState();
                        yy_.yytext = yy_.yytext.slice(0, -10).trim();
                        return 26;
                    case 39:
                        return 44;
                    case 40:
                        return 45;
                    case 41:
                        return 46;
                    case 42:
                        return 47;
                    case 43:
                        this.pushState("STATE_STRING");
                        break;
                    case 44:
                        this.pushState("STATE_ID");
                        return "AS";
                    case 45:
                        this.popState();
                        return "ID";
                    case 46:
                        this.popState();
                        break;
                    case 47:
                        return "STATE_DESCR";
                    case 48:
                        return 18;
                    case 49:
                        this.popState();
                        break;
                    case 50:
                        this.popState();
                        this.pushState("struct");
                        return 19;
                    case 51:
                        break;
                    case 52:
                        this.popState();
                        return 20;
                    case 53:
                        break;
                    case 54:
                        this.begin("NOTE");
                        return 28;
                    case 55:
                        this.popState();
                        this.pushState("NOTE_ID");
                        return 52;
                    case 56:
                        this.popState();
                        this.pushState("NOTE_ID");
                        return 53;
                    case 57:
                        this.popState();
                        this.pushState("FLOATING_NOTE");
                        break;
                    case 58:
                        this.popState();
                        this.pushState("FLOATING_NOTE_ID");
                        return "AS";
                    case 59:
                        break;
                    case 60:
                        return "NOTE_TEXT";
                    case 61:
                        this.popState();
                        return "ID";
                    case 62:
                        this.popState();
                        this.pushState("NOTE_TEXT");
                        return 23;
                    case 63:
                        this.popState();
                        yy_.yytext = yy_.yytext.substr(2).trim();
                        return 30;
                    case 64:
                        this.popState();
                        yy_.yytext = yy_.yytext.slice(0, -8).trim();
                        return 30;
                    case 65:
                        return 6;
                    case 66:
                        return 6;
                    case 67:
                        return 15;
                    case 68:
                        return 50;
                    case 69:
                        return 23;
                    case 70:
                        yy_.yytext = yy_.yytext.trim();
                        return 13;
                    case 71:
                        return 14;
                    case 72:
                        return 27;
                    case 73:
                        return 51;
                    case 74:
                        return 5;
                    case 75:
                        return "INVALID";
                }
            },
            rules: [
                /^(?:default\b)/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:[\s]+)/i,
                /^(?:((?!\n)\s)+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:%[^\n]*)/i,
                /^(?:scale\s+)/i,
                /^(?:\d+)/i,
                /^(?:\s+width\b)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:classDef\s+)/i,
                /^(?:DEFAULT\s+)/i,
                /^(?:\w+\s+)/i,
                /^(?:[^\n]*)/i,
                /^(?:class\s+)/i,
                /^(?:(\w+)+((,\s*\w+)*))/i,
                /^(?:[^\n]*)/i,
                /^(?:scale\s+)/i,
                /^(?:\d+)/i,
                /^(?:\s+width\b)/i,
                /^(?:state\s+)/i,
                /^(?:.*<<fork>>)/i,
                /^(?:.*<<join>>)/i,
                /^(?:.*<<choice>>)/i,
                /^(?:.*\[\[fork\]\])/i,
                /^(?:.*\[\[join\]\])/i,
                /^(?:.*\[\[choice\]\])/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:["])/i,
                /^(?:\s*as\s+)/i,
                /^(?:[^\n\{]*)/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:[^\n\s\{]+)/i,
                /^(?:\n)/i,
                /^(?:\{)/i,
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:\})/i,
                /^(?:[\n])/i,
                /^(?:note\s+)/i,
                /^(?:left of\b)/i,
                /^(?:right of\b)/i,
                /^(?:")/i,
                /^(?:\s*as\s*)/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:[^\n]*)/i,
                /^(?:\s*[^:\n\s\-]+)/i,
                /^(?:\s*:[^:\n;]+)/i,
                /^(?:[\s\S]*?end note\b)/i,
                /^(?:stateDiagram\s+)/i,
                /^(?:stateDiagram-v2\s+)/i,
                /^(?:hide empty description\b)/i,
                /^(?:\[\*\])/i,
                /^(?:[^:\n\s\-\{]+)/i,
                /^(?:\s*:[^:\n;]+)/i,
                /^(?:-->)/i,
                /^(?:--)/i,
                /^(?::::)/i,
                /^(?:$)/i,
                /^(?:.)/i
            ],
            conditions: {
                "LINE": {
                    "rules": [
                        9,
                        10
                    ],
                    "inclusive": false
                },
                "struct": {
                    "rules": [
                        9,
                        10,
                        22,
                        26,
                        32,
                        39,
                        40,
                        41,
                        42,
                        51,
                        52,
                        53,
                        54,
                        68,
                        69,
                        70,
                        71,
                        72
                    ],
                    "inclusive": false
                },
                "FLOATING_NOTE_ID": {
                    "rules": [
                        61
                    ],
                    "inclusive": false
                },
                "FLOATING_NOTE": {
                    "rules": [
                        58,
                        59,
                        60
                    ],
                    "inclusive": false
                },
                "NOTE_TEXT": {
                    "rules": [
                        63,
                        64
                    ],
                    "inclusive": false
                },
                "NOTE_ID": {
                    "rules": [
                        62
                    ],
                    "inclusive": false
                },
                "NOTE": {
                    "rules": [
                        55,
                        56,
                        57
                    ],
                    "inclusive": false
                },
                "CLASS_STYLE": {
                    "rules": [
                        28
                    ],
                    "inclusive": false
                },
                "CLASS": {
                    "rules": [
                        27
                    ],
                    "inclusive": false
                },
                "CLASSDEFID": {
                    "rules": [
                        25
                    ],
                    "inclusive": false
                },
                "CLASSDEF": {
                    "rules": [
                        23,
                        24
                    ],
                    "inclusive": false
                },
                "acc_descr_multiline": {
                    "rules": [
                        20,
                        21
                    ],
                    "inclusive": false
                },
                "acc_descr": {
                    "rules": [
                        18
                    ],
                    "inclusive": false
                },
                "acc_title": {
                    "rules": [
                        16
                    ],
                    "inclusive": false
                },
                "SCALE": {
                    "rules": [
                        13,
                        14,
                        30,
                        31
                    ],
                    "inclusive": false
                },
                "ALIAS": {
                    "rules": [],
                    "inclusive": false
                },
                "STATE_ID": {
                    "rules": [
                        45
                    ],
                    "inclusive": false
                },
                "STATE_STRING": {
                    "rules": [
                        46,
                        47
                    ],
                    "inclusive": false
                },
                "FORK_STATE": {
                    "rules": [],
                    "inclusive": false
                },
                "STATE": {
                    "rules": [
                        9,
                        10,
                        33,
                        34,
                        35,
                        36,
                        37,
                        38,
                        43,
                        44,
                        48,
                        49,
                        50
                    ],
                    "inclusive": false
                },
                "ID": {
                    "rules": [
                        9,
                        10
                    ],
                    "inclusive": false
                },
                "INITIAL": {
                    "rules": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        10,
                        11,
                        12,
                        15,
                        17,
                        19,
                        22,
                        26,
                        29,
                        32,
                        50,
                        54,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        73,
                        74,
                        75
                    ],
                    "inclusive": true
                }
            }
        };
        return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
        this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
}();
parser.parser = parser;
const parser$1 = parser;
const DEFAULT_DIAGRAM_DIRECTION = "LR";
const DEFAULT_NESTED_DOC_DIR = "TB";
const STMT_STATE = "state";
const STMT_RELATION = "relation";
const STMT_CLASSDEF = "classDef";
const STMT_APPLYCLASS = "applyClass";
const DEFAULT_STATE_TYPE = "default";
const DIVIDER_TYPE = "divider";
const START_NODE = "[*]";
const START_TYPE = "start";
const END_NODE = START_NODE;
const END_TYPE = "end";
const COLOR_KEYWORD = "color";
const FILL_KEYWORD = "fill";
const BG_FILL = "bgFill";
const STYLECLASS_SEP = ",";
function newClassesList() {
    return {};
}
let direction = DEFAULT_DIAGRAM_DIRECTION;
let rootDoc = [];
let classes = newClassesList();
const newDoc = ()=>{
    return {
        relations: [],
        states: {},
        documents: {}
    };
};
let documents = {
    root: newDoc()
};
let currentDocument = documents.root;
let startEndCount = 0;
let dividerCnt = 0;
const lineType = {
    LINE: 0,
    DOTTED_LINE: 1
};
const relationType = {
    AGGREGATION: 0,
    EXTENSION: 1,
    COMPOSITION: 2,
    DEPENDENCY: 3
};
const clone = (o)=>JSON.parse(JSON.stringify(o));
const setRootDoc = (o)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Setting root doc", o);
    rootDoc = o;
};
const getRootDoc = ()=>rootDoc;
const docTranslator = (parent, node, first)=>{
    if (node.stmt === STMT_RELATION) {
        docTranslator(parent, node.state1, true);
        docTranslator(parent, node.state2, false);
    } else {
        if (node.stmt === STMT_STATE) {
            if (node.id === "[*]") {
                node.id = first ? parent.id + "_start" : parent.id + "_end";
                node.start = first;
            } else {
                node.id = node.id.trim();
            }
        }
        if (node.doc) {
            const doc = [];
            let currentDoc = [];
            let i;
            for(i = 0; i < node.doc.length; i++){
                if (node.doc[i].type === DIVIDER_TYPE) {
                    const newNode = clone(node.doc[i]);
                    newNode.doc = clone(currentDoc);
                    doc.push(newNode);
                    currentDoc = [];
                } else {
                    currentDoc.push(node.doc[i]);
                }
            }
            if (doc.length > 0 && currentDoc.length > 0) {
                const newNode = {
                    stmt: STMT_STATE,
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["I"])(),
                    type: "divider",
                    doc: clone(currentDoc)
                };
                doc.push(clone(newNode));
                node.doc = doc;
            }
            node.doc.forEach((docNode)=>docTranslator(node, docNode, true));
        }
    }
};
const getRootDocV2 = ()=>{
    docTranslator({
        id: "root"
    }, {
        id: "root",
        doc: rootDoc
    }, true);
    return {
        id: "root",
        doc: rootDoc
    };
};
const extract = (_doc)=>{
    let doc;
    if (_doc.doc) {
        doc = _doc.doc;
    } else {
        doc = _doc;
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info(doc);
    clear(true);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Extract", doc);
    doc.forEach((item)=>{
        switch(item.stmt){
            case STMT_STATE:
                addState(item.id.trim(), item.type, item.doc, item.description, item.note, item.classes, item.styles, item.textStyles);
                break;
            case STMT_RELATION:
                addRelation(item.state1, item.state2, item.description);
                break;
            case STMT_CLASSDEF:
                addStyleClass(item.id.trim(), item.classes);
                break;
            case STMT_APPLYCLASS:
                setCssClass(item.id.trim(), item.styleClass);
                break;
        }
    });
};
const addState = function(id, type = DEFAULT_STATE_TYPE, doc = null, descr = null, note = null, classes2 = null, styles2 = null, textStyles = null) {
    const trimmedId = id == null ? void 0 : id.trim();
    if (currentDocument.states[trimmedId] === void 0) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Adding state ", trimmedId, descr);
        currentDocument.states[trimmedId] = {
            id: trimmedId,
            descriptions: [],
            type,
            doc,
            note,
            classes: [],
            styles: [],
            textStyles: []
        };
    } else {
        if (!currentDocument.states[trimmedId].doc) {
            currentDocument.states[trimmedId].doc = doc;
        }
        if (!currentDocument.states[trimmedId].type) {
            currentDocument.states[trimmedId].type = type;
        }
    }
    if (descr) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Setting state description", trimmedId, descr);
        if (typeof descr === "string") {
            addDescription(trimmedId, descr.trim());
        }
        if (typeof descr === "object") {
            descr.forEach((des)=>addDescription(trimmedId, des.trim()));
        }
    }
    if (note) {
        currentDocument.states[trimmedId].note = note;
        currentDocument.states[trimmedId].note.text = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"].sanitizeText(currentDocument.states[trimmedId].note.text, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])());
    }
    if (classes2) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Setting state classes", trimmedId, classes2);
        const classesList = typeof classes2 === "string" ? [
            classes2
        ] : classes2;
        classesList.forEach((cssClass)=>setCssClass(trimmedId, cssClass.trim()));
    }
    if (styles2) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Setting state styles", trimmedId, styles2);
        const stylesList = typeof styles2 === "string" ? [
            styles2
        ] : styles2;
        stylesList.forEach((style)=>setStyle(trimmedId, style.trim()));
    }
    if (textStyles) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Setting state styles", trimmedId, styles2);
        const textStylesList = typeof textStyles === "string" ? [
            textStyles
        ] : textStyles;
        textStylesList.forEach((textStyle)=>setTextStyle(trimmedId, textStyle.trim()));
    }
};
const clear = function(saveCommon) {
    documents = {
        root: newDoc()
    };
    currentDocument = documents.root;
    startEndCount = 0;
    classes = newClassesList();
    if (!saveCommon) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"])();
    }
};
const getState = function(id) {
    return currentDocument.states[id];
};
const getStates = function() {
    return currentDocument.states;
};
const logDocuments = function() {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Documents = ", documents);
};
const getRelations = function() {
    return currentDocument.relations;
};
function startIdIfNeeded(id = "") {
    let fixedId = id;
    if (id === START_NODE) {
        startEndCount++;
        fixedId = `${START_TYPE}${startEndCount}`;
    }
    return fixedId;
}
function startTypeIfNeeded(id = "", type = DEFAULT_STATE_TYPE) {
    return id === START_NODE ? START_TYPE : type;
}
function endIdIfNeeded(id = "") {
    let fixedId = id;
    if (id === END_NODE) {
        startEndCount++;
        fixedId = `${END_TYPE}${startEndCount}`;
    }
    return fixedId;
}
function endTypeIfNeeded(id = "", type = DEFAULT_STATE_TYPE) {
    return id === END_NODE ? END_TYPE : type;
}
function addRelationObjs(item1, item2, relationTitle) {
    let id1 = startIdIfNeeded(item1.id.trim());
    let type1 = startTypeIfNeeded(item1.id.trim(), item1.type);
    let id2 = startIdIfNeeded(item2.id.trim());
    let type2 = startTypeIfNeeded(item2.id.trim(), item2.type);
    addState(id1, type1, item1.doc, item1.description, item1.note, item1.classes, item1.styles, item1.textStyles);
    addState(id2, type2, item2.doc, item2.description, item2.note, item2.classes, item2.styles, item2.textStyles);
    currentDocument.relations.push({
        id1,
        id2,
        relationTitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"].sanitizeText(relationTitle, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])())
    });
}
const addRelation = function(item1, item2, title) {
    if (typeof item1 === "object") {
        addRelationObjs(item1, item2, title);
    } else {
        const id1 = startIdIfNeeded(item1.trim());
        const type1 = startTypeIfNeeded(item1);
        const id2 = endIdIfNeeded(item2.trim());
        const type2 = endTypeIfNeeded(item2);
        addState(id1, type1);
        addState(id2, type2);
        currentDocument.relations.push({
            id1,
            id2,
            title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"].sanitizeText(title, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])())
        });
    }
};
const addDescription = function(id, descr) {
    const theState = currentDocument.states[id];
    const _descr = descr.startsWith(":") ? descr.replace(":", "").trim() : descr;
    theState.descriptions.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"].sanitizeText(_descr, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])()));
};
const cleanupLabel = function(label) {
    if (label.substring(0, 1) === ":") {
        return label.substr(2).trim();
    } else {
        return label.trim();
    }
};
const getDividerId = ()=>{
    dividerCnt++;
    return "divider-id-" + dividerCnt;
};
const addStyleClass = function(id, styleAttributes = "") {
    if (classes[id] === void 0) {
        classes[id] = {
            id,
            styles: [],
            textStyles: []
        };
    }
    const foundClass = classes[id];
    if (styleAttributes !== void 0 && styleAttributes !== null) {
        styleAttributes.split(STYLECLASS_SEP).forEach((attrib)=>{
            const fixedAttrib = attrib.replace(/([^;]*);/, "$1").trim();
            if (attrib.match(COLOR_KEYWORD)) {
                const newStyle1 = fixedAttrib.replace(FILL_KEYWORD, BG_FILL);
                const newStyle2 = newStyle1.replace(COLOR_KEYWORD, FILL_KEYWORD);
                foundClass.textStyles.push(newStyle2);
            }
            foundClass.styles.push(fixedAttrib);
        });
    }
};
const getClasses = function() {
    return classes;
};
const setCssClass = function(itemIds, cssClassName) {
    itemIds.split(",").forEach(function(id) {
        let foundState = getState(id);
        if (foundState === void 0) {
            const trimmedId = id.trim();
            addState(trimmedId);
            foundState = getState(trimmedId);
        }
        foundState.classes.push(cssClassName);
    });
};
const setStyle = function(itemId, styleText) {
    const item = getState(itemId);
    if (item !== void 0) {
        item.textStyles.push(styleText);
    }
};
const setTextStyle = function(itemId, cssClassName) {
    const item = getState(itemId);
    if (item !== void 0) {
        item.textStyles.push(cssClassName);
    }
};
const getDirection = ()=>direction;
const setDirection = (dir)=>{
    direction = dir;
};
const trimColon = (str)=>str && str[0] === ":" ? str.substr(1).trim() : str.trim();
const db = {
    getConfig: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().state,
    addState,
    clear,
    getState,
    getStates,
    getRelations,
    getClasses,
    getDirection,
    addRelation,
    getDividerId,
    setDirection,
    cleanupLabel,
    lineType,
    relationType,
    logDocuments,
    getRootDoc,
    setRootDoc,
    getRootDocV2,
    extract,
    trimColon,
    getAccTitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"],
    setAccTitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"],
    getAccDescription: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"],
    setAccDescription: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"],
    addStyleClass,
    setCssClass,
    addDescription,
    setDiagramTitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["q"],
    getDiagramTitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"]
};
const getStyles = (options)=>`
defs #statediagram-barbEnd {
    fill: ${options.transitionColor};
    stroke: ${options.transitionColor};
  }
g.stateGroup text {
  fill: ${options.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${options.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${options.stateLabelColor};
}

g.stateGroup rect {
  fill: ${options.mainBkg};
  stroke: ${options.nodeBorder};
}

g.stateGroup line {
  stroke: ${options.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${options.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${options.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${options.noteBorderColor};
  fill: ${options.noteBkgColor};

  text {
    fill: ${options.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${options.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${options.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel .label text {
  fill: ${options.transitionLabelColor || options.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${options.transitionLabelColor || options.tertiaryTextColor};
}

.stateLabel text {
  fill: ${options.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${options.specialStateColor};
  stroke: ${options.specialStateColor};
}

.node .fork-join {
  fill: ${options.specialStateColor};
  stroke: ${options.specialStateColor};
}

.node circle.state-end {
  fill: ${options.innerEndBackground};
  stroke: ${options.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${options.compositeBackground || options.background};
  // stroke: ${options.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${options.stateBkg || options.mainBkg};
  stroke: ${options.stateBorder || options.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${options.mainBkg};
  stroke: ${options.stateBorder || options.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${options.lineColor};
}

.statediagram-cluster rect {
  fill: ${options.compositeTitleBackground};
  stroke: ${options.stateBorder || options.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${options.stateLabelColor};
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${options.stateBorder || options.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${options.compositeBackground || options.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${options.altBackground ? options.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${options.altBackground ? options.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${options.noteBkgColor};
  stroke: ${options.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${options.noteBkgColor};
  stroke: ${options.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${options.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${options.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${options.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${options.lineColor};
  stroke: ${options.lineColor};
  stroke-width: 1;
}

.statediagramTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${options.textColor};
}
`;
const styles = getStyles;
;
}}),
"[project]/node_modules/mermaid/dist/createText-2e5e7dd3.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "a": (()=>createText),
    "c": (()=>computeDimensionOfText)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/mermaid-b5860b54.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mdast$2d$util$2d$from$2d$markdown$2f$dev$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mdast-util-from-markdown/dev/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ts$2d$dedent$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ts-dedent/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function preprocessMarkdown(markdown) {
    const withoutMultipleNewlines = markdown.replace(/\n{2,}/g, "\n");
    const withoutExtraSpaces = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ts$2d$dedent$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["dedent"])(withoutMultipleNewlines);
    return withoutExtraSpaces;
}
function markdownToLines(markdown) {
    const preprocessedMarkdown = preprocessMarkdown(markdown);
    const { children } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mdast$2d$util$2d$from$2d$markdown$2f$dev$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromMarkdown"])(preprocessedMarkdown);
    const lines = [
        []
    ];
    let currentLine = 0;
    function processNode(node, parentType = "normal") {
        if (node.type === "text") {
            const textLines = node.value.split("\n");
            textLines.forEach((textLine, index)=>{
                if (index !== 0) {
                    currentLine++;
                    lines.push([]);
                }
                textLine.split(" ").forEach((word)=>{
                    if (word) {
                        lines[currentLine].push({
                            content: word,
                            type: parentType
                        });
                    }
                });
            });
        } else if (node.type === "strong" || node.type === "emphasis") {
            node.children.forEach((contentNode)=>{
                processNode(contentNode, node.type);
            });
        }
    }
    children.forEach((treeNode)=>{
        if (treeNode.type === "paragraph") {
            treeNode.children.forEach((contentNode)=>{
                processNode(contentNode);
            });
        }
    });
    return lines;
}
function markdownToHTML(markdown) {
    const { children } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mdast$2d$util$2d$from$2d$markdown$2f$dev$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromMarkdown"])(markdown);
    function output(node) {
        if (node.type === "text") {
            return node.value.replace(/\n/g, "<br/>");
        } else if (node.type === "strong") {
            return `<strong>${node.children.map(output).join("")}</strong>`;
        } else if (node.type === "emphasis") {
            return `<em>${node.children.map(output).join("")}</em>`;
        } else if (node.type === "paragraph") {
            return `<p>${node.children.map(output).join("")}</p>`;
        }
        return `Unsupported markdown: ${node.type}`;
    }
    return children.map(output).join("");
}
function splitTextToChars(text) {
    if (Intl.Segmenter) {
        return [
            ...new Intl.Segmenter().segment(text)
        ].map((s)=>s.segment);
    }
    return [
        ...text
    ];
}
function splitWordToFitWidth(checkFit, word) {
    const characters = splitTextToChars(word.content);
    return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);
}
function splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {
    if (remainingChars.length === 0) {
        return [
            {
                content: usedChars.join(""),
                type
            },
            {
                content: "",
                type
            }
        ];
    }
    const [nextChar, ...rest] = remainingChars;
    const newWord = [
        ...usedChars,
        nextChar
    ];
    if (checkFit([
        {
            content: newWord.join(""),
            type
        }
    ])) {
        return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);
    }
    if (usedChars.length === 0 && nextChar) {
        usedChars.push(nextChar);
        remainingChars.shift();
    }
    return [
        {
            content: usedChars.join(""),
            type
        },
        {
            content: remainingChars.join(""),
            type
        }
    ];
}
function splitLineToFitWidth(line, checkFit) {
    if (line.some(({ content })=>content.includes("\n"))) {
        throw new Error("splitLineToFitWidth does not support newlines in the line");
    }
    return splitLineToFitWidthRecursion(line, checkFit);
}
function splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {
    if (words.length === 0) {
        if (newLine.length > 0) {
            lines.push(newLine);
        }
        return lines.length > 0 ? lines : [];
    }
    let joiner = "";
    if (words[0].content === " ") {
        joiner = " ";
        words.shift();
    }
    const nextWord = words.shift() ?? {
        content: " ",
        type: "normal"
    };
    const lineWithNextWord = [
        ...newLine
    ];
    if (joiner !== "") {
        lineWithNextWord.push({
            content: joiner,
            type: "normal"
        });
    }
    lineWithNextWord.push(nextWord);
    if (checkFit(lineWithNextWord)) {
        return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);
    }
    if (newLine.length > 0) {
        lines.push(newLine);
        words.unshift(nextWord);
    } else if (nextWord.content) {
        const [line, rest] = splitWordToFitWidth(checkFit, nextWord);
        lines.push([
            line
        ]);
        if (rest.content) {
            words.unshift(rest);
        }
    }
    return splitLineToFitWidthRecursion(words, checkFit, lines);
}
function applyStyle(dom, styleFn) {
    if (styleFn) {
        dom.attr("style", styleFn);
    }
}
function addHtmlSpan(element, node, width, classes, addBackground = false) {
    const fo = element.append("foreignObject");
    const div = fo.append("xhtml:div");
    const label = node.label;
    const labelClass = node.isNode ? "nodeLabel" : "edgeLabel";
    div.html(`
    <span class="${labelClass} ${classes}" ` + (node.labelStyle ? 'style="' + node.labelStyle + '"' : "") + ">" + label + "</span>");
    applyStyle(div, node.labelStyle);
    div.style("display", "table-cell");
    div.style("white-space", "nowrap");
    div.style("max-width", width + "px");
    div.attr("xmlns", "http://www.w3.org/1999/xhtml");
    if (addBackground) {
        div.attr("class", "labelBkg");
    }
    let bbox = div.node().getBoundingClientRect();
    if (bbox.width === width) {
        div.style("display", "table");
        div.style("white-space", "break-spaces");
        div.style("width", width + "px");
        bbox = div.node().getBoundingClientRect();
    }
    fo.style("width", bbox.width);
    fo.style("height", bbox.height);
    return fo.node();
}
function createTspan(textElement, lineIndex, lineHeight) {
    return textElement.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", lineIndex * lineHeight - 0.1 + "em").attr("dy", lineHeight + "em");
}
function computeWidthOfText(parentNode, lineHeight, line) {
    const testElement = parentNode.append("text");
    const testSpan = createTspan(testElement, 1, lineHeight);
    updateTextContentAndStyles(testSpan, line);
    const textLength = testSpan.node().getComputedTextLength();
    testElement.remove();
    return textLength;
}
function computeDimensionOfText(parentNode, lineHeight, text) {
    var _a;
    const testElement = parentNode.append("text");
    const testSpan = createTspan(testElement, 1, lineHeight);
    updateTextContentAndStyles(testSpan, [
        {
            content: text,
            type: "normal"
        }
    ]);
    const textDimension = (_a = testSpan.node()) == null ? void 0 : _a.getBoundingClientRect();
    if (textDimension) {
        testElement.remove();
    }
    return textDimension;
}
function createFormattedText(width, g, structuredText, addBackground = false) {
    const lineHeight = 1.1;
    const labelGroup = g.append("g");
    const bkg = labelGroup.insert("rect").attr("class", "background");
    const textElement = labelGroup.append("text").attr("y", "-10.1");
    let lineIndex = 0;
    for (const line of structuredText){
        const checkWidth = (line2)=>computeWidthOfText(labelGroup, lineHeight, line2) <= width;
        const linesUnderWidth = checkWidth(line) ? [
            line
        ] : splitLineToFitWidth(line, checkWidth);
        for (const preparedLine of linesUnderWidth){
            const tspan = createTspan(textElement, lineIndex, lineHeight);
            updateTextContentAndStyles(tspan, preparedLine);
            lineIndex++;
        }
    }
    if (addBackground) {
        const bbox = textElement.node().getBBox();
        const padding = 2;
        bkg.attr("x", -padding).attr("y", -padding).attr("width", bbox.width + 2 * padding).attr("height", bbox.height + 2 * padding);
        return labelGroup.node();
    } else {
        return textElement.node();
    }
}
function updateTextContentAndStyles(tspan, wrappedLine) {
    tspan.text("");
    wrappedLine.forEach((word, index)=>{
        const innerTspan = tspan.append("tspan").attr("font-style", word.type === "emphasis" ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", word.type === "strong" ? "bold" : "normal");
        if (index === 0) {
            innerTspan.text(word.content);
        } else {
            innerTspan.text(" " + word.content);
        }
    });
}
const createText = (el, text = "", { style = "", isTitle = false, classes = "", useHtmlLabels = true, isNode = true, width = 200, addSvgBackground = false } = {})=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("createText", text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);
    if (useHtmlLabels) {
        const htmlText = markdownToHTML(text);
        const node = {
            isNode,
            label: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["M"])(htmlText).replace(/fa[blrs]?:fa-[\w-]+/g, // cspell: disable-line
            (s)=>`<i class='${s.replace(":", " ")}'></i>`),
            labelStyle: style.replace("fill:", "color:")
        };
        const vertexNode = addHtmlSpan(el, node, width, classes, addSvgBackground);
        return vertexNode;
    } else {
        const structuredText = markdownToLines(text);
        const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);
        return svgLabel;
    }
};
;
}}),
"[project]/node_modules/mermaid/dist/edges-e0da2a9e.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "a": (()=>insertMarkers$1),
    "b": (()=>clear$1),
    "c": (()=>createLabel$1),
    "d": (()=>clear),
    "e": (()=>insertNode),
    "f": (()=>insertEdgeLabel),
    "g": (()=>getSubGraphTitleMargins),
    "h": (()=>insertEdge),
    "i": (()=>intersectRect$1),
    "j": (()=>positionEdgeLabel),
    "k": (()=>getLineFunctionsWithOffset),
    "l": (()=>labelHelper),
    "m": (()=>addEdgeMarkers),
    "p": (()=>positionNode),
    "s": (()=>setNodeElem),
    "u": (()=>updateNodeBounds)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/mermaid-b5860b54.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/d3/src/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-selection/src/select.js [app-ssr] (ecmascript) <export default as select>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$shape$2f$src$2f$line$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__line$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-shape/src/line.js [app-ssr] (ecmascript) <export default as line>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$shape$2f$src$2f$curve$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__curveBasis$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-shape/src/curve/basis.js [app-ssr] (ecmascript) <export default as curveBasis>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$createText$2d$2e5e7dd3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/createText-2e5e7dd3.js [app-ssr] (ecmascript)");
;
;
;
const insertMarkers = (elem, markerArray, type, id)=>{
    markerArray.forEach((markerName)=>{
        markers[markerName](elem, type, id);
    });
};
const extension = (elem, type, id)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Making markers for ", id);
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-extensionStart").attr("class", "marker extension " + type).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-extensionEnd").attr("class", "marker extension " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
};
const composition = (elem, type, id)=>{
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-compositionStart").attr("class", "marker composition " + type).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-compositionEnd").attr("class", "marker composition " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
};
const aggregation = (elem, type, id)=>{
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-aggregationStart").attr("class", "marker aggregation " + type).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-aggregationEnd").attr("class", "marker aggregation " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
};
const dependency = (elem, type, id)=>{
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-dependencyStart").attr("class", "marker dependency " + type).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-dependencyEnd").attr("class", "marker dependency " + type).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
};
const lollipop = (elem, type, id)=>{
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-lollipopStart").attr("class", "marker lollipop " + type).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-lollipopEnd").attr("class", "marker lollipop " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
};
const point = (elem, type, id)=>{
    elem.append("marker").attr("id", id + "_" + type + "-pointEnd").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 6).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    elem.append("marker").attr("id", id + "_" + type + "-pointStart").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
};
const circle$1 = (elem, type, id)=>{
    elem.append("marker").attr("id", id + "_" + type + "-circleEnd").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    elem.append("marker").attr("id", id + "_" + type + "-circleStart").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
};
const cross = (elem, type, id)=>{
    elem.append("marker").attr("id", id + "_" + type + "-crossEnd").attr("class", "marker cross " + type).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
    elem.append("marker").attr("id", id + "_" + type + "-crossStart").attr("class", "marker cross " + type).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
};
const barb = (elem, type, id)=>{
    elem.append("defs").append("marker").attr("id", id + "_" + type + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
};
const markers = {
    extension,
    composition,
    aggregation,
    dependency,
    lollipop,
    point,
    circle: circle$1,
    cross,
    barb
};
const insertMarkers$1 = insertMarkers;
function applyStyle(dom, styleFn) {
    if (styleFn) {
        dom.attr("style", styleFn);
    }
}
function addHtmlLabel(node) {
    const fo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"));
    const div = fo.append("xhtml:div");
    const label = node.label;
    const labelClass = node.isNode ? "nodeLabel" : "edgeLabel";
    div.html('<span class="' + labelClass + '" ' + (node.labelStyle ? 'style="' + node.labelStyle + '"' : "") + ">" + label + "</span>");
    applyStyle(div, node.labelStyle);
    div.style("display", "inline-block");
    div.style("white-space", "nowrap");
    div.attr("xmlns", "http://www.w3.org/1999/xhtml");
    return fo.node();
}
const createLabel = (_vertexText, style, isTitle, isNode)=>{
    let vertexText = _vertexText || "";
    if (typeof vertexText === "object") {
        vertexText = vertexText[0];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels)) {
        vertexText = vertexText.replace(/\\n|\n/g, "<br />");
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("vertexText" + vertexText);
        const node = {
            isNode,
            label: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["M"])(vertexText).replace(/fa[blrs]?:fa-[\w-]+/g, // cspell: disable-line
            (s)=>`<i class='${s.replace(":", " ")}'></i>`),
            labelStyle: style.replace("fill:", "color:")
        };
        let vertexNode = addHtmlLabel(node);
        return vertexNode;
    } else {
        const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
        svgLabel.setAttribute("style", style.replace("color:", "fill:"));
        let rows = [];
        if (typeof vertexText === "string") {
            rows = vertexText.split(/\\n|\n|<br\s*\/?>/gi);
        } else if (Array.isArray(vertexText)) {
            rows = vertexText;
        } else {
            rows = [];
        }
        for (const row of rows){
            const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
            tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            tspan.setAttribute("dy", "1em");
            tspan.setAttribute("x", "0");
            if (isTitle) {
                tspan.setAttribute("class", "title-row");
            } else {
                tspan.setAttribute("class", "row");
            }
            tspan.textContent = row.trim();
            svgLabel.appendChild(tspan);
        }
        return svgLabel;
    }
};
const createLabel$1 = createLabel;
const labelHelper = async (parent, node, _classes, isNode)=>{
    let classes;
    const useHtmlLabels = node.useHtmlLabels || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels);
    if (!_classes) {
        classes = "node default";
    } else {
        classes = _classes;
    }
    const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);
    const label = shapeSvg.insert("g").attr("class", "label").attr("style", node.labelStyle);
    let labelText;
    if (node.labelText === void 0) {
        labelText = "";
    } else {
        labelText = typeof node.labelText === "string" ? node.labelText : node.labelText[0];
    }
    const textNode = label.node();
    let text;
    if (node.labelType === "markdown") {
        text = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$createText$2d$2e5e7dd3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(label, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["M"])(labelText), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])()), {
            useHtmlLabels,
            width: node.width || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.wrappingWidth,
            classes: "markdown-node-label"
        });
    } else {
        text = textNode.appendChild(createLabel$1((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["M"])(labelText), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])()), node.labelStyle, false, isNode));
    }
    let bbox = text.getBBox();
    const halfPadding = node.padding / 2;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels)) {
        const div = text.children[0];
        const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(text);
        const images = div.getElementsByTagName("img");
        if (images) {
            const noImgText = labelText.replace(/<img[^>]*>/g, "").trim() === "";
            await Promise.all([
                ...images
            ].map((img)=>new Promise((res)=>{
                    function setupImage() {
                        img.style.display = "flex";
                        img.style.flexDirection = "column";
                        if (noImgText) {
                            const bodyFontSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().fontSize ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().fontSize : window.getComputedStyle(document.body).fontSize;
                            const enlargingFactor = 5;
                            const width = parseInt(bodyFontSize, 10) * enlargingFactor + "px";
                            img.style.minWidth = width;
                            img.style.maxWidth = width;
                        } else {
                            img.style.width = "100%";
                        }
                        res(img);
                    }
                    setTimeout(()=>{
                        if (img.complete) {
                            setupImage();
                        }
                    });
                    img.addEventListener("error", setupImage);
                    img.addEventListener("load", setupImage);
                })));
        }
        bbox = div.getBoundingClientRect();
        dv.attr("width", bbox.width);
        dv.attr("height", bbox.height);
    }
    if (useHtmlLabels) {
        label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
    } else {
        label.attr("transform", "translate(0, " + -bbox.height / 2 + ")");
    }
    if (node.centerLabel) {
        label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
    }
    label.insert("rect", ":first-child");
    return {
        shapeSvg,
        bbox,
        halfPadding,
        label
    };
};
const updateNodeBounds = (node, element)=>{
    const bbox = element.node().getBBox();
    node.width = bbox.width;
    node.height = bbox.height;
};
function insertPolygonShape(parent, w, h, points) {
    return parent.insert("polygon", ":first-child").attr("points", points.map(function(d) {
        return d.x + "," + d.y;
    }).join(" ")).attr("class", "label-container").attr("transform", "translate(" + -w / 2 + "," + h / 2 + ")");
}
function intersectNode(node, point2) {
    return node.intersect(point2);
}
function intersectEllipse(node, rx, ry, point2) {
    var cx = node.x;
    var cy = node.y;
    var px = cx - point2.x;
    var py = cy - point2.y;
    var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
    var dx = Math.abs(rx * ry * px / det);
    if (point2.x < cx) {
        dx = -dx;
    }
    var dy = Math.abs(rx * ry * py / det);
    if (point2.y < cy) {
        dy = -dy;
    }
    return {
        x: cx + dx,
        y: cy + dy
    };
}
function intersectCircle(node, rx, point2) {
    return intersectEllipse(node, rx, rx, point2);
}
function intersectLine(p1, p2, q1, q2) {
    var a1, a2, b1, b2, c1, c2;
    var r1, r2, r3, r4;
    var denom, offset, num;
    var x, y;
    a1 = p2.y - p1.y;
    b1 = p1.x - p2.x;
    c1 = p2.x * p1.y - p1.x * p2.y;
    r3 = a1 * q1.x + b1 * q1.y + c1;
    r4 = a1 * q2.x + b1 * q2.y + c1;
    if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {
        return;
    }
    a2 = q2.y - q1.y;
    b2 = q1.x - q2.x;
    c2 = q2.x * q1.y - q1.x * q2.y;
    r1 = a2 * p1.x + b2 * p1.y + c2;
    r2 = a2 * p2.x + b2 * p2.y + c2;
    if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {
        return;
    }
    denom = a1 * b2 - a2 * b1;
    if (denom === 0) {
        return;
    }
    offset = Math.abs(denom / 2);
    num = b1 * c2 - b2 * c1;
    x = num < 0 ? (num - offset) / denom : (num + offset) / denom;
    num = a2 * c1 - a1 * c2;
    y = num < 0 ? (num - offset) / denom : (num + offset) / denom;
    return {
        x,
        y
    };
}
function sameSign(r1, r2) {
    return r1 * r2 > 0;
}
function intersectPolygon(node, polyPoints, point2) {
    var x1 = node.x;
    var y1 = node.y;
    var intersections = [];
    var minX = Number.POSITIVE_INFINITY;
    var minY = Number.POSITIVE_INFINITY;
    if (typeof polyPoints.forEach === "function") {
        polyPoints.forEach(function(entry) {
            minX = Math.min(minX, entry.x);
            minY = Math.min(minY, entry.y);
        });
    } else {
        minX = Math.min(minX, polyPoints.x);
        minY = Math.min(minY, polyPoints.y);
    }
    var left = x1 - node.width / 2 - minX;
    var top = y1 - node.height / 2 - minY;
    for(var i = 0; i < polyPoints.length; i++){
        var p1 = polyPoints[i];
        var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
        var intersect2 = intersectLine(node, point2, {
            x: left + p1.x,
            y: top + p1.y
        }, {
            x: left + p2.x,
            y: top + p2.y
        });
        if (intersect2) {
            intersections.push(intersect2);
        }
    }
    if (!intersections.length) {
        return node;
    }
    if (intersections.length > 1) {
        intersections.sort(function(p, q) {
            var pdx = p.x - point2.x;
            var pdy = p.y - point2.y;
            var distp = Math.sqrt(pdx * pdx + pdy * pdy);
            var qdx = q.x - point2.x;
            var qdy = q.y - point2.y;
            var distq = Math.sqrt(qdx * qdx + qdy * qdy);
            return distp < distq ? -1 : distp === distq ? 0 : 1;
        });
    }
    return intersections[0];
}
const intersectRect = (node, point2)=>{
    var x = node.x;
    var y = node.y;
    var dx = point2.x - x;
    var dy = point2.y - y;
    var w = node.width / 2;
    var h = node.height / 2;
    var sx, sy;
    if (Math.abs(dy) * w > Math.abs(dx) * h) {
        if (dy < 0) {
            h = -h;
        }
        sx = dy === 0 ? 0 : h * dx / dy;
        sy = h;
    } else {
        if (dx < 0) {
            w = -w;
        }
        sx = w;
        sy = dx === 0 ? 0 : w * dy / dx;
    }
    return {
        x: x + sx,
        y: y + sy
    };
};
const intersectRect$1 = intersectRect;
const intersect = {
    node: intersectNode,
    circle: intersectCircle,
    ellipse: intersectEllipse,
    polygon: intersectPolygon,
    rect: intersectRect$1
};
const note = async (parent, node)=>{
    const useHtmlLabels = node.useHtmlLabels || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels;
    if (!useHtmlLabels) {
        node.centerLabel = true;
    }
    const { shapeSvg, bbox, halfPadding } = await labelHelper(parent, node, "node " + node.classes, true);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Classes = ", node.classes);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    rect2.attr("rx", node.rx).attr("ry", node.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);
    updateNodeBounds(node, rect2);
    node.intersect = function(point2) {
        return intersect.rect(node, point2);
    };
    return shapeSvg;
};
const note$1 = note;
const expandAndDeduplicateDirections = (directions)=>{
    const uniqueDirections = /* @__PURE__ */ new Set();
    for (const direction of directions){
        switch(direction){
            case "x":
                uniqueDirections.add("right");
                uniqueDirections.add("left");
                break;
            case "y":
                uniqueDirections.add("up");
                uniqueDirections.add("down");
                break;
            default:
                uniqueDirections.add(direction);
                break;
        }
    }
    return uniqueDirections;
};
const getArrowPoints = (duplicatedDirections, bbox, node)=>{
    const directions = expandAndDeduplicateDirections(duplicatedDirections);
    const f = 2;
    const height = bbox.height + 2 * node.padding;
    const midpoint = height / f;
    const width = bbox.width + 2 * midpoint + node.padding;
    const padding = node.padding / 2;
    if (directions.has("right") && directions.has("left") && directions.has("up") && directions.has("down")) {
        return [
            // Bottom
            {
                x: 0,
                y: 0
            },
            {
                x: midpoint,
                y: 0
            },
            {
                x: width / 2,
                y: 2 * padding
            },
            {
                x: width - midpoint,
                y: 0
            },
            {
                x: width,
                y: 0
            },
            // Right
            {
                x: width,
                y: -height / 3
            },
            {
                x: width + 2 * padding,
                y: -height / 2
            },
            {
                x: width,
                y: -2 * height / 3
            },
            {
                x: width,
                y: -height
            },
            // Top
            {
                x: width - midpoint,
                y: -height
            },
            {
                x: width / 2,
                y: -height - 2 * padding
            },
            {
                x: midpoint,
                y: -height
            },
            // Left
            {
                x: 0,
                y: -height
            },
            {
                x: 0,
                y: -2 * height / 3
            },
            {
                x: -2 * padding,
                y: -height / 2
            },
            {
                x: 0,
                y: -height / 3
            }
        ];
    }
    if (directions.has("right") && directions.has("left") && directions.has("up")) {
        return [
            {
                x: midpoint,
                y: 0
            },
            {
                x: width - midpoint,
                y: 0
            },
            {
                x: width,
                y: -height / 2
            },
            {
                x: width - midpoint,
                y: -height
            },
            {
                x: midpoint,
                y: -height
            },
            {
                x: 0,
                y: -height / 2
            }
        ];
    }
    if (directions.has("right") && directions.has("left") && directions.has("down")) {
        return [
            {
                x: 0,
                y: 0
            },
            {
                x: midpoint,
                y: -height
            },
            {
                x: width - midpoint,
                y: -height
            },
            {
                x: width,
                y: 0
            }
        ];
    }
    if (directions.has("right") && directions.has("up") && directions.has("down")) {
        return [
            {
                x: 0,
                y: 0
            },
            {
                x: width,
                y: -midpoint
            },
            {
                x: width,
                y: -height + midpoint
            },
            {
                x: 0,
                y: -height
            }
        ];
    }
    if (directions.has("left") && directions.has("up") && directions.has("down")) {
        return [
            {
                x: width,
                y: 0
            },
            {
                x: 0,
                y: -midpoint
            },
            {
                x: 0,
                y: -height + midpoint
            },
            {
                x: width,
                y: -height
            }
        ];
    }
    if (directions.has("right") && directions.has("left")) {
        return [
            {
                x: midpoint,
                y: 0
            },
            {
                x: midpoint,
                y: -padding
            },
            {
                x: width - midpoint,
                y: -padding
            },
            {
                x: width - midpoint,
                y: 0
            },
            {
                x: width,
                y: -height / 2
            },
            {
                x: width - midpoint,
                y: -height
            },
            {
                x: width - midpoint,
                y: -height + padding
            },
            {
                x: midpoint,
                y: -height + padding
            },
            {
                x: midpoint,
                y: -height
            },
            {
                x: 0,
                y: -height / 2
            }
        ];
    }
    if (directions.has("up") && directions.has("down")) {
        return [
            // Bottom center
            {
                x: width / 2,
                y: 0
            },
            // Left pont of bottom arrow
            {
                x: 0,
                y: -padding
            },
            {
                x: midpoint,
                y: -padding
            },
            // Left top over vertical section
            {
                x: midpoint,
                y: -height + padding
            },
            {
                x: 0,
                y: -height + padding
            },
            // Top of arrow
            {
                x: width / 2,
                y: -height
            },
            {
                x: width,
                y: -height + padding
            },
            // Top of right vertical bar
            {
                x: width - midpoint,
                y: -height + padding
            },
            {
                x: width - midpoint,
                y: -padding
            },
            {
                x: width,
                y: -padding
            }
        ];
    }
    if (directions.has("right") && directions.has("up")) {
        return [
            {
                x: 0,
                y: 0
            },
            {
                x: width,
                y: -midpoint
            },
            {
                x: 0,
                y: -height
            }
        ];
    }
    if (directions.has("right") && directions.has("down")) {
        return [
            {
                x: 0,
                y: 0
            },
            {
                x: width,
                y: 0
            },
            {
                x: 0,
                y: -height
            }
        ];
    }
    if (directions.has("left") && directions.has("up")) {
        return [
            {
                x: width,
                y: 0
            },
            {
                x: 0,
                y: -midpoint
            },
            {
                x: width,
                y: -height
            }
        ];
    }
    if (directions.has("left") && directions.has("down")) {
        return [
            {
                x: width,
                y: 0
            },
            {
                x: 0,
                y: 0
            },
            {
                x: width,
                y: -height
            }
        ];
    }
    if (directions.has("right")) {
        return [
            {
                x: midpoint,
                y: -padding
            },
            {
                x: midpoint,
                y: -padding
            },
            {
                x: width - midpoint,
                y: -padding
            },
            {
                x: width - midpoint,
                y: 0
            },
            {
                x: width,
                y: -height / 2
            },
            {
                x: width - midpoint,
                y: -height
            },
            {
                x: width - midpoint,
                y: -height + padding
            },
            // top left corner of arrow
            {
                x: midpoint,
                y: -height + padding
            },
            {
                x: midpoint,
                y: -height + padding
            }
        ];
    }
    if (directions.has("left")) {
        return [
            {
                x: midpoint,
                y: 0
            },
            {
                x: midpoint,
                y: -padding
            },
            // Two points, the right corners
            {
                x: width - midpoint,
                y: -padding
            },
            {
                x: width - midpoint,
                y: -height + padding
            },
            {
                x: midpoint,
                y: -height + padding
            },
            {
                x: midpoint,
                y: -height
            },
            {
                x: 0,
                y: -height / 2
            }
        ];
    }
    if (directions.has("up")) {
        return [
            // Bottom center
            {
                x: midpoint,
                y: -padding
            },
            // Left top over vertical section
            {
                x: midpoint,
                y: -height + padding
            },
            {
                x: 0,
                y: -height + padding
            },
            // Top of arrow
            {
                x: width / 2,
                y: -height
            },
            {
                x: width,
                y: -height + padding
            },
            // Top of right vertical bar
            {
                x: width - midpoint,
                y: -height + padding
            },
            {
                x: width - midpoint,
                y: -padding
            }
        ];
    }
    if (directions.has("down")) {
        return [
            // Bottom center
            {
                x: width / 2,
                y: 0
            },
            // Left pont of bottom arrow
            {
                x: 0,
                y: -padding
            },
            {
                x: midpoint,
                y: -padding
            },
            // Left top over vertical section
            {
                x: midpoint,
                y: -height + padding
            },
            {
                x: width - midpoint,
                y: -height + padding
            },
            {
                x: width - midpoint,
                y: -padding
            },
            {
                x: width,
                y: -padding
            }
        ];
    }
    return [
        {
            x: 0,
            y: 0
        }
    ];
};
const formatClass = (str)=>{
    if (str) {
        return " " + str;
    }
    return "";
};
const getClassesFromNode = (node, otherClasses)=>{
    return `${otherClasses ? otherClasses : "node default"}${formatClass(node.classes)} ${formatClass(node.class)}`;
};
const question = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const w = bbox.width + node.padding;
    const h = bbox.height + node.padding;
    const s = w + h;
    const points = [
        {
            x: s / 2,
            y: 0
        },
        {
            x: s,
            y: -s / 2
        },
        {
            x: s / 2,
            y: -s
        },
        {
            x: 0,
            y: -s / 2
        }
    ];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Question main (Circle)");
    const questionElem = insertPolygonShape(shapeSvg, s, s, points);
    questionElem.attr("style", node.style);
    updateNodeBounds(node, questionElem);
    node.intersect = function(point2) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Intersect called");
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const choice = (parent, node)=>{
    const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);
    const s = 28;
    const points = [
        {
            x: 0,
            y: s / 2
        },
        {
            x: s / 2,
            y: 0
        },
        {
            x: 0,
            y: -s / 2
        },
        {
            x: -s / 2,
            y: 0
        }
    ];
    const choice2 = shapeSvg.insert("polygon", ":first-child").attr("points", points.map(function(d) {
        return d.x + "," + d.y;
    }).join(" "));
    choice2.attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28);
    node.width = 28;
    node.height = 28;
    node.intersect = function(point2) {
        return intersect.circle(node, 14, point2);
    };
    return shapeSvg;
};
const hexagon = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const f = 4;
    const h = bbox.height + node.padding;
    const m = h / f;
    const w = bbox.width + 2 * m + node.padding;
    const points = [
        {
            x: m,
            y: 0
        },
        {
            x: w - m,
            y: 0
        },
        {
            x: w,
            y: -h / 2
        },
        {
            x: w - m,
            y: -h
        },
        {
            x: m,
            y: -h
        },
        {
            x: 0,
            y: -h / 2
        }
    ];
    const hex = insertPolygonShape(shapeSvg, w, h, points);
    hex.attr("style", node.style);
    updateNodeBounds(node, hex);
    node.intersect = function(point2) {
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const block_arrow = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);
    const f = 2;
    const h = bbox.height + 2 * node.padding;
    const m = h / f;
    const w = bbox.width + 2 * m + node.padding;
    const points = getArrowPoints(node.directions, bbox, node);
    const blockArrow = insertPolygonShape(shapeSvg, w, h, points);
    blockArrow.attr("style", node.style);
    updateNodeBounds(node, blockArrow);
    node.intersect = function(point2) {
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const rect_left_inv_arrow = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const w = bbox.width + node.padding;
    const h = bbox.height + node.padding;
    const points = [
        {
            x: -h / 2,
            y: 0
        },
        {
            x: w,
            y: 0
        },
        {
            x: w,
            y: -h
        },
        {
            x: -h / 2,
            y: -h
        },
        {
            x: 0,
            y: -h / 2
        }
    ];
    const el = insertPolygonShape(shapeSvg, w, h, points);
    el.attr("style", node.style);
    node.width = w + h;
    node.height = h;
    node.intersect = function(point2) {
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const lean_right = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node), true);
    const w = bbox.width + node.padding;
    const h = bbox.height + node.padding;
    const points = [
        {
            x: -2 * h / 6,
            y: 0
        },
        {
            x: w - h / 6,
            y: 0
        },
        {
            x: w + 2 * h / 6,
            y: -h
        },
        {
            x: h / 6,
            y: -h
        }
    ];
    const el = insertPolygonShape(shapeSvg, w, h, points);
    el.attr("style", node.style);
    updateNodeBounds(node, el);
    node.intersect = function(point2) {
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const lean_left = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const w = bbox.width + node.padding;
    const h = bbox.height + node.padding;
    const points = [
        {
            x: 2 * h / 6,
            y: 0
        },
        {
            x: w + h / 6,
            y: 0
        },
        {
            x: w - 2 * h / 6,
            y: -h
        },
        {
            x: -h / 6,
            y: -h
        }
    ];
    const el = insertPolygonShape(shapeSvg, w, h, points);
    el.attr("style", node.style);
    updateNodeBounds(node, el);
    node.intersect = function(point2) {
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const trapezoid = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const w = bbox.width + node.padding;
    const h = bbox.height + node.padding;
    const points = [
        {
            x: -2 * h / 6,
            y: 0
        },
        {
            x: w + 2 * h / 6,
            y: 0
        },
        {
            x: w - h / 6,
            y: -h
        },
        {
            x: h / 6,
            y: -h
        }
    ];
    const el = insertPolygonShape(shapeSvg, w, h, points);
    el.attr("style", node.style);
    updateNodeBounds(node, el);
    node.intersect = function(point2) {
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const inv_trapezoid = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const w = bbox.width + node.padding;
    const h = bbox.height + node.padding;
    const points = [
        {
            x: h / 6,
            y: 0
        },
        {
            x: w - h / 6,
            y: 0
        },
        {
            x: w + 2 * h / 6,
            y: -h
        },
        {
            x: -2 * h / 6,
            y: -h
        }
    ];
    const el = insertPolygonShape(shapeSvg, w, h, points);
    el.attr("style", node.style);
    updateNodeBounds(node, el);
    node.intersect = function(point2) {
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const rect_right_inv_arrow = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const w = bbox.width + node.padding;
    const h = bbox.height + node.padding;
    const points = [
        {
            x: 0,
            y: 0
        },
        {
            x: w + h / 2,
            y: 0
        },
        {
            x: w,
            y: -h / 2
        },
        {
            x: w + h / 2,
            y: -h
        },
        {
            x: 0,
            y: -h
        }
    ];
    const el = insertPolygonShape(shapeSvg, w, h, points);
    el.attr("style", node.style);
    updateNodeBounds(node, el);
    node.intersect = function(point2) {
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const cylinder = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const w = bbox.width + node.padding;
    const rx = w / 2;
    const ry = rx / (2.5 + w / 50);
    const h = bbox.height + ry + node.padding;
    const shape = "M 0," + ry + " a " + rx + "," + ry + " 0,0,0 " + w + " 0 a " + rx + "," + ry + " 0,0,0 " + -w + " 0 l 0," + h + " a " + rx + "," + ry + " 0,0,0 " + w + " 0 l 0," + -h;
    const el = shapeSvg.attr("label-offset-y", ry).insert("path", ":first-child").attr("style", node.style).attr("d", shape).attr("transform", "translate(" + -w / 2 + "," + -(h / 2 + ry) + ")");
    updateNodeBounds(node, el);
    node.intersect = function(point2) {
        const pos = intersect.rect(node, point2);
        const x = pos.x - node.x;
        if (rx != 0 && (Math.abs(x) < node.width / 2 || Math.abs(x) == node.width / 2 && Math.abs(pos.y - node.y) > node.height / 2 - ry)) {
            let y = ry * ry * (1 - x * x / (rx * rx));
            if (y != 0) {
                y = Math.sqrt(y);
            }
            y = ry - y;
            if (point2.y - node.y > 0) {
                y = -y;
            }
            pos.y += y;
        }
        return pos;
    };
    return shapeSvg;
};
const rect = async (parent, node)=>{
    const { shapeSvg, bbox, halfPadding } = await labelHelper(parent, node, "node " + node.classes + " " + node.class, true);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const totalWidth = node.positioned ? node.width : bbox.width + node.padding;
    const totalHeight = node.positioned ? node.height : bbox.height + node.padding;
    const x = node.positioned ? -totalWidth / 2 : -bbox.width / 2 - halfPadding;
    const y = node.positioned ? -totalHeight / 2 : -bbox.height / 2 - halfPadding;
    rect2.attr("class", "basic label-container").attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("x", x).attr("y", y).attr("width", totalWidth).attr("height", totalHeight);
    if (node.props) {
        const propKeys = new Set(Object.keys(node.props));
        if (node.props.borders) {
            applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);
            propKeys.delete("borders");
        }
        propKeys.forEach((propKey)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn(`Unknown node property ${propKey}`);
        });
    }
    updateNodeBounds(node, rect2);
    node.intersect = function(point2) {
        return intersect.rect(node, point2);
    };
    return shapeSvg;
};
const composite = async (parent, node)=>{
    const { shapeSvg, bbox, halfPadding } = await labelHelper(parent, node, "node " + node.classes, true);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const totalWidth = node.positioned ? node.width : bbox.width + node.padding;
    const totalHeight = node.positioned ? node.height : bbox.height + node.padding;
    const x = node.positioned ? -totalWidth / 2 : -bbox.width / 2 - halfPadding;
    const y = node.positioned ? -totalHeight / 2 : -bbox.height / 2 - halfPadding;
    rect2.attr("class", "basic cluster composite label-container").attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("x", x).attr("y", y).attr("width", totalWidth).attr("height", totalHeight);
    if (node.props) {
        const propKeys = new Set(Object.keys(node.props));
        if (node.props.borders) {
            applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);
            propKeys.delete("borders");
        }
        propKeys.forEach((propKey)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn(`Unknown node property ${propKey}`);
        });
    }
    updateNodeBounds(node, rect2);
    node.intersect = function(point2) {
        return intersect.rect(node, point2);
    };
    return shapeSvg;
};
const labelRect = async (parent, node)=>{
    const { shapeSvg } = await labelHelper(parent, node, "label", true);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Classes = ", node.class);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const totalWidth = 0;
    const totalHeight = 0;
    rect2.attr("width", totalWidth).attr("height", totalHeight);
    shapeSvg.attr("class", "label edgeLabel");
    if (node.props) {
        const propKeys = new Set(Object.keys(node.props));
        if (node.props.borders) {
            applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);
            propKeys.delete("borders");
        }
        propKeys.forEach((propKey)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn(`Unknown node property ${propKey}`);
        });
    }
    updateNodeBounds(node, rect2);
    node.intersect = function(point2) {
        return intersect.rect(node, point2);
    };
    return shapeSvg;
};
function applyNodePropertyBorders(rect2, borders, totalWidth, totalHeight) {
    const strokeDashArray = [];
    const addBorder = (length)=>{
        strokeDashArray.push(length, 0);
    };
    const skipBorder = (length)=>{
        strokeDashArray.push(0, length);
    };
    if (borders.includes("t")) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("add top border");
        addBorder(totalWidth);
    } else {
        skipBorder(totalWidth);
    }
    if (borders.includes("r")) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("add right border");
        addBorder(totalHeight);
    } else {
        skipBorder(totalHeight);
    }
    if (borders.includes("b")) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("add bottom border");
        addBorder(totalWidth);
    } else {
        skipBorder(totalWidth);
    }
    if (borders.includes("l")) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("add left border");
        addBorder(totalHeight);
    } else {
        skipBorder(totalHeight);
    }
    rect2.attr("stroke-dasharray", strokeDashArray.join(" "));
}
const rectWithTitle = (parent, node)=>{
    let classes;
    if (!node.classes) {
        classes = "node default";
    } else {
        classes = "node " + node.classes;
    }
    const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const innerLine = shapeSvg.insert("line");
    const label = shapeSvg.insert("g").attr("class", "label");
    const text2 = node.labelText.flat ? node.labelText.flat() : node.labelText;
    let title = "";
    if (typeof text2 === "object") {
        title = text2[0];
    } else {
        title = text2;
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Label text abc79", title, text2, typeof text2 === "object");
    const text = label.node().appendChild(createLabel$1(title, node.labelStyle, true, true));
    let bbox = {
        width: 0,
        height: 0
    };
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels)) {
        const div = text.children[0];
        const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(text);
        bbox = div.getBoundingClientRect();
        dv.attr("width", bbox.width);
        dv.attr("height", bbox.height);
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Text 2", text2);
    const textRows = text2.slice(1, text2.length);
    let titleBox = text.getBBox();
    const descr = label.node().appendChild(createLabel$1(textRows.join ? textRows.join("<br/>") : textRows, node.labelStyle, true, true));
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels)) {
        const div = descr.children[0];
        const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(descr);
        bbox = div.getBoundingClientRect();
        dv.attr("width", bbox.width);
        dv.attr("height", bbox.height);
    }
    const halfPadding = node.padding / 2;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(descr).attr("transform", "translate( " + // (titleBox.width - bbox.width) / 2 +
    (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + ", " + (titleBox.height + halfPadding + 5) + ")");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(text).attr("transform", "translate( " + // (titleBox.width - bbox.width) / 2 +
    (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + ", 0)");
    bbox = label.node().getBBox();
    label.attr("transform", "translate(" + -bbox.width / 2 + ", " + (-bbox.height / 2 - halfPadding + 3) + ")");
    rect2.attr("class", "outer title-state").attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);
    innerLine.attr("class", "divider").attr("x1", -bbox.width / 2 - halfPadding).attr("x2", bbox.width / 2 + halfPadding).attr("y1", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr("y2", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);
    updateNodeBounds(node, rect2);
    node.intersect = function(point2) {
        return intersect.rect(node, point2);
    };
    return shapeSvg;
};
const stadium = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const h = bbox.height + node.padding;
    const w = bbox.width + h / 4 + node.padding;
    const rect2 = shapeSvg.insert("rect", ":first-child").attr("style", node.style).attr("rx", h / 2).attr("ry", h / 2).attr("x", -w / 2).attr("y", -h / 2).attr("width", w).attr("height", h);
    updateNodeBounds(node, rect2);
    node.intersect = function(point2) {
        return intersect.rect(node, point2);
    };
    return shapeSvg;
};
const circle = async (parent, node)=>{
    const { shapeSvg, bbox, halfPadding } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const circle2 = shapeSvg.insert("circle", ":first-child");
    circle2.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Circle main");
    updateNodeBounds(node, circle2);
    node.intersect = function(point2) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Circle intersect", node, bbox.width / 2 + halfPadding, point2);
        return intersect.circle(node, bbox.width / 2 + halfPadding, point2);
    };
    return shapeSvg;
};
const doublecircle = async (parent, node)=>{
    const { shapeSvg, bbox, halfPadding } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const gap = 5;
    const circleGroup = shapeSvg.insert("g", ":first-child");
    const outerCircle = circleGroup.insert("circle");
    const innerCircle = circleGroup.insert("circle");
    circleGroup.attr("class", node.class);
    outerCircle.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("r", bbox.width / 2 + halfPadding + gap).attr("width", bbox.width + node.padding + gap * 2).attr("height", bbox.height + node.padding + gap * 2);
    innerCircle.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("DoubleCircle main");
    updateNodeBounds(node, outerCircle);
    node.intersect = function(point2) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("DoubleCircle intersect", node, bbox.width / 2 + halfPadding + gap, point2);
        return intersect.circle(node, bbox.width / 2 + halfPadding + gap, point2);
    };
    return shapeSvg;
};
const subroutine = async (parent, node)=>{
    const { shapeSvg, bbox } = await labelHelper(parent, node, getClassesFromNode(node, void 0), true);
    const w = bbox.width + node.padding;
    const h = bbox.height + node.padding;
    const points = [
        {
            x: 0,
            y: 0
        },
        {
            x: w,
            y: 0
        },
        {
            x: w,
            y: -h
        },
        {
            x: 0,
            y: -h
        },
        {
            x: 0,
            y: 0
        },
        {
            x: -8,
            y: 0
        },
        {
            x: w + 8,
            y: 0
        },
        {
            x: w + 8,
            y: -h
        },
        {
            x: -8,
            y: -h
        },
        {
            x: -8,
            y: 0
        }
    ];
    const el = insertPolygonShape(shapeSvg, w, h, points);
    el.attr("style", node.style);
    updateNodeBounds(node, el);
    node.intersect = function(point2) {
        return intersect.polygon(node, points, point2);
    };
    return shapeSvg;
};
const start = (parent, node)=>{
    const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);
    const circle2 = shapeSvg.insert("circle", ":first-child");
    circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
    updateNodeBounds(node, circle2);
    node.intersect = function(point2) {
        return intersect.circle(node, 7, point2);
    };
    return shapeSvg;
};
const forkJoin = (parent, node, dir)=>{
    const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);
    let width = 70;
    let height = 10;
    if (dir === "LR") {
        width = 10;
        height = 70;
    }
    const shape = shapeSvg.append("rect").attr("x", -1 * width / 2).attr("y", -1 * height / 2).attr("width", width).attr("height", height).attr("class", "fork-join");
    updateNodeBounds(node, shape);
    node.height = node.height + node.padding / 2;
    node.width = node.width + node.padding / 2;
    node.intersect = function(point2) {
        return intersect.rect(node, point2);
    };
    return shapeSvg;
};
const end = (parent, node)=>{
    const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);
    const innerCircle = shapeSvg.insert("circle", ":first-child");
    const circle2 = shapeSvg.insert("circle", ":first-child");
    circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
    innerCircle.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10);
    updateNodeBounds(node, circle2);
    node.intersect = function(point2) {
        return intersect.circle(node, 7, point2);
    };
    return shapeSvg;
};
const class_box = (parent, node)=>{
    const halfPadding = node.padding / 2;
    const rowPadding = 4;
    const lineHeight = 8;
    let classes;
    if (!node.classes) {
        classes = "node default";
    } else {
        classes = "node " + node.classes;
    }
    const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const topLine = shapeSvg.insert("line");
    const bottomLine = shapeSvg.insert("line");
    let maxWidth = 0;
    let maxHeight = rowPadding;
    const labelContainer = shapeSvg.insert("g").attr("class", "label");
    let verticalPos = 0;
    const hasInterface = node.classData.annotations && node.classData.annotations[0];
    const interfaceLabelText = node.classData.annotations[0] ? "" + node.classData.annotations[0] + "" : "";
    const interfaceLabel = labelContainer.node().appendChild(createLabel$1(interfaceLabelText, node.labelStyle, true, true));
    let interfaceBBox = interfaceLabel.getBBox();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels)) {
        const div = interfaceLabel.children[0];
        const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(interfaceLabel);
        interfaceBBox = div.getBoundingClientRect();
        dv.attr("width", interfaceBBox.width);
        dv.attr("height", interfaceBBox.height);
    }
    if (node.classData.annotations[0]) {
        maxHeight += interfaceBBox.height + rowPadding;
        maxWidth += interfaceBBox.width;
    }
    let classTitleString = node.classData.label;
    if (node.classData.type !== void 0 && node.classData.type !== "") {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels) {
            classTitleString += "&lt;" + node.classData.type + "&gt;";
        } else {
            classTitleString += "<" + node.classData.type + ">";
        }
    }
    const classTitleLabel = labelContainer.node().appendChild(createLabel$1(classTitleString, node.labelStyle, true, true));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(classTitleLabel).attr("class", "classTitle");
    let classTitleBBox = classTitleLabel.getBBox();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels)) {
        const div = classTitleLabel.children[0];
        const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(classTitleLabel);
        classTitleBBox = div.getBoundingClientRect();
        dv.attr("width", classTitleBBox.width);
        dv.attr("height", classTitleBBox.height);
    }
    maxHeight += classTitleBBox.height + rowPadding;
    if (classTitleBBox.width > maxWidth) {
        maxWidth = classTitleBBox.width;
    }
    const classAttributes = [];
    node.classData.members.forEach((member)=>{
        const parsedInfo = member.getDisplayDetails();
        let parsedText = parsedInfo.displayText;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels) {
            parsedText = parsedText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        const lbl = labelContainer.node().appendChild(createLabel$1(parsedText, parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle, true, true));
        let bbox = lbl.getBBox();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels)) {
            const div = lbl.children[0];
            const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(lbl);
            bbox = div.getBoundingClientRect();
            dv.attr("width", bbox.width);
            dv.attr("height", bbox.height);
        }
        if (bbox.width > maxWidth) {
            maxWidth = bbox.width;
        }
        maxHeight += bbox.height + rowPadding;
        classAttributes.push(lbl);
    });
    maxHeight += lineHeight;
    const classMethods = [];
    node.classData.methods.forEach((member)=>{
        const parsedInfo = member.getDisplayDetails();
        let displayText = parsedInfo.displayText;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels) {
            displayText = displayText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        const lbl = labelContainer.node().appendChild(createLabel$1(displayText, parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle, true, true));
        let bbox = lbl.getBBox();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels)) {
            const div = lbl.children[0];
            const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(lbl);
            bbox = div.getBoundingClientRect();
            dv.attr("width", bbox.width);
            dv.attr("height", bbox.height);
        }
        if (bbox.width > maxWidth) {
            maxWidth = bbox.width;
        }
        maxHeight += bbox.height + rowPadding;
        classMethods.push(lbl);
    });
    maxHeight += lineHeight;
    if (hasInterface) {
        let diffX2 = (maxWidth - interfaceBBox.width) / 2;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(interfaceLabel).attr("transform", "translate( " + (-1 * maxWidth / 2 + diffX2) + ", " + -1 * maxHeight / 2 + ")");
        verticalPos = interfaceBBox.height + rowPadding;
    }
    let diffX = (maxWidth - classTitleBBox.width) / 2;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(classTitleLabel).attr("transform", "translate( " + (-1 * maxWidth / 2 + diffX) + ", " + (-1 * maxHeight / 2 + verticalPos) + ")");
    verticalPos += classTitleBBox.height + rowPadding;
    topLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
    verticalPos += lineHeight;
    classAttributes.forEach((lbl)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(lbl).attr("transform", "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos + lineHeight / 2) + ")");
        const memberBBox = lbl == null ? void 0 : lbl.getBBox();
        verticalPos += ((memberBBox == null ? void 0 : memberBBox.height) ?? 0) + rowPadding;
    });
    verticalPos += lineHeight;
    bottomLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
    verticalPos += lineHeight;
    classMethods.forEach((lbl)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(lbl).attr("transform", "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos) + ")");
        const memberBBox = lbl == null ? void 0 : lbl.getBBox();
        verticalPos += ((memberBBox == null ? void 0 : memberBBox.height) ?? 0) + rowPadding;
    });
    rect2.attr("style", node.style).attr("class", "outer title-state").attr("x", -maxWidth / 2 - halfPadding).attr("y", -(maxHeight / 2) - halfPadding).attr("width", maxWidth + node.padding).attr("height", maxHeight + node.padding);
    updateNodeBounds(node, rect2);
    node.intersect = function(point2) {
        return intersect.rect(node, point2);
    };
    return shapeSvg;
};
const shapes = {
    rhombus: question,
    composite,
    question,
    rect,
    labelRect,
    rectWithTitle,
    choice,
    circle,
    doublecircle,
    stadium,
    hexagon,
    block_arrow,
    rect_left_inv_arrow,
    lean_right,
    lean_left,
    trapezoid,
    inv_trapezoid,
    rect_right_inv_arrow,
    cylinder,
    start,
    end,
    note: note$1,
    subroutine,
    fork: forkJoin,
    join: forkJoin,
    class_box
};
let nodeElems = {};
const insertNode = async (elem, node, dir)=>{
    let newEl;
    let el;
    if (node.link) {
        let target;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().securityLevel === "sandbox") {
            target = "_top";
        } else if (node.linkTarget) {
            target = node.linkTarget || "_blank";
        }
        newEl = elem.insert("svg:a").attr("xlink:href", node.link).attr("target", target);
        el = await shapes[node.shape](newEl, node, dir);
    } else {
        el = await shapes[node.shape](elem, node, dir);
        newEl = el;
    }
    if (node.tooltip) {
        el.attr("title", node.tooltip);
    }
    if (node.class) {
        el.attr("class", "node default " + node.class);
    }
    newEl.attr("data-node", "true");
    newEl.attr("data-id", node.id);
    nodeElems[node.id] = newEl;
    if (node.haveCallback) {
        nodeElems[node.id].attr("class", nodeElems[node.id].attr("class") + " clickable");
    }
    return newEl;
};
const setNodeElem = (elem, node)=>{
    nodeElems[node.id] = elem;
};
const clear$1 = ()=>{
    nodeElems = {};
};
const positionNode = (node)=>{
    const el = nodeElems[node.id];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Transforming node", node.diff, node, "translate(" + (node.x - node.width / 2 - 5) + ", " + node.width / 2 + ")");
    const padding = 8;
    const diff = node.diff || 0;
    if (node.clusterNode) {
        el.attr("transform", "translate(" + (node.x + diff - node.width / 2) + ", " + (node.y - node.height / 2 - padding) + ")");
    } else {
        el.attr("transform", "translate(" + node.x + ", " + node.y + ")");
    }
    return diff;
};
const getSubGraphTitleMargins = ({ flowchart })=>{
    var _a, _b;
    const subGraphTitleTopMargin = ((_a = flowchart == null ? void 0 : flowchart.subGraphTitleMargin) == null ? void 0 : _a.top) ?? 0;
    const subGraphTitleBottomMargin = ((_b = flowchart == null ? void 0 : flowchart.subGraphTitleMargin) == null ? void 0 : _b.bottom) ?? 0;
    const subGraphTitleTotalMargin = subGraphTitleTopMargin + subGraphTitleBottomMargin;
    return {
        subGraphTitleTopMargin,
        subGraphTitleBottomMargin,
        subGraphTitleTotalMargin
    };
};
const markerOffsets = {
    aggregation: 18,
    extension: 18,
    composition: 18,
    dependency: 6,
    lollipop: 13.5,
    arrow_point: 5.3
};
function calculateDeltaAndAngle(point1, point2) {
    if (point1 === void 0 || point2 === void 0) {
        return {
            angle: 0,
            deltaX: 0,
            deltaY: 0
        };
    }
    point1 = pointTransformer(point1);
    point2 = pointTransformer(point2);
    const [x1, y1] = [
        point1.x,
        point1.y
    ];
    const [x2, y2] = [
        point2.x,
        point2.y
    ];
    const deltaX = x2 - x1;
    const deltaY = y2 - y1;
    return {
        angle: Math.atan(deltaY / deltaX),
        deltaX,
        deltaY
    };
}
const pointTransformer = (data)=>{
    if (Array.isArray(data)) {
        return {
            x: data[0],
            y: data[1]
        };
    }
    return data;
};
const getLineFunctionsWithOffset = (edge)=>{
    return {
        x: function(d, i, data) {
            let offset = 0;
            if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {
                const { angle, deltaX } = calculateDeltaAndAngle(data[0], data[1]);
                offset = markerOffsets[edge.arrowTypeStart] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);
            } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {
                const { angle, deltaX } = calculateDeltaAndAngle(data[data.length - 1], data[data.length - 2]);
                offset = markerOffsets[edge.arrowTypeEnd] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);
            }
            return pointTransformer(d).x + offset;
        },
        y: function(d, i, data) {
            let offset = 0;
            if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {
                const { angle, deltaY } = calculateDeltaAndAngle(data[0], data[1]);
                offset = markerOffsets[edge.arrowTypeStart] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);
            } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {
                const { angle, deltaY } = calculateDeltaAndAngle(data[data.length - 1], data[data.length - 2]);
                offset = markerOffsets[edge.arrowTypeEnd] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);
            }
            return pointTransformer(d).y + offset;
        }
    };
};
const addEdgeMarkers = (svgPath, edge, url, id, diagramType)=>{
    if (edge.arrowTypeStart) {
        addEdgeMarker(svgPath, "start", edge.arrowTypeStart, url, id, diagramType);
    }
    if (edge.arrowTypeEnd) {
        addEdgeMarker(svgPath, "end", edge.arrowTypeEnd, url, id, diagramType);
    }
};
const arrowTypesMap = {
    arrow_cross: "cross",
    arrow_point: "point",
    arrow_barb: "barb",
    arrow_circle: "circle",
    aggregation: "aggregation",
    extension: "extension",
    composition: "composition",
    dependency: "dependency",
    lollipop: "lollipop"
};
const addEdgeMarker = (svgPath, position, arrowType, url, id, diagramType)=>{
    const endMarkerType = arrowTypesMap[arrowType];
    if (!endMarkerType) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn(`Unknown arrow type: ${arrowType}`);
        return;
    }
    const suffix = position === "start" ? "Start" : "End";
    svgPath.attr(`marker-${position}`, `url(${url}#${id}_${diagramType}-${endMarkerType}${suffix})`);
};
let edgeLabels = {};
let terminalLabels = {};
const clear = ()=>{
    edgeLabels = {};
    terminalLabels = {};
};
const insertEdgeLabel = (elem, edge)=>{
    const useHtmlLabels = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels);
    const labelElement = edge.labelType === "markdown" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$createText$2d$2e5e7dd3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(elem, edge.label, {
        style: edge.labelStyle,
        useHtmlLabels,
        addSvgBackground: true
    }) : createLabel$1(edge.label, edge.labelStyle);
    const edgeLabel = elem.insert("g").attr("class", "edgeLabel");
    const label = edgeLabel.insert("g").attr("class", "label");
    label.node().appendChild(labelElement);
    let bbox = labelElement.getBBox();
    if (useHtmlLabels) {
        const div = labelElement.children[0];
        const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(labelElement);
        bbox = div.getBoundingClientRect();
        dv.attr("width", bbox.width);
        dv.attr("height", bbox.height);
    }
    label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
    edgeLabels[edge.id] = edgeLabel;
    edge.width = bbox.width;
    edge.height = bbox.height;
    let fo;
    if (edge.startLabelLeft) {
        const startLabelElement = createLabel$1(edge.startLabelLeft, edge.labelStyle);
        const startEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
        const inner = startEdgeLabelLeft.insert("g").attr("class", "inner");
        fo = inner.node().appendChild(startLabelElement);
        const slBox = startLabelElement.getBBox();
        inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
        if (!terminalLabels[edge.id]) {
            terminalLabels[edge.id] = {};
        }
        terminalLabels[edge.id].startLeft = startEdgeLabelLeft;
        setTerminalWidth(fo, edge.startLabelLeft);
    }
    if (edge.startLabelRight) {
        const startLabelElement = createLabel$1(edge.startLabelRight, edge.labelStyle);
        const startEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
        const inner = startEdgeLabelRight.insert("g").attr("class", "inner");
        fo = startEdgeLabelRight.node().appendChild(startLabelElement);
        inner.node().appendChild(startLabelElement);
        const slBox = startLabelElement.getBBox();
        inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
        if (!terminalLabels[edge.id]) {
            terminalLabels[edge.id] = {};
        }
        terminalLabels[edge.id].startRight = startEdgeLabelRight;
        setTerminalWidth(fo, edge.startLabelRight);
    }
    if (edge.endLabelLeft) {
        const endLabelElement = createLabel$1(edge.endLabelLeft, edge.labelStyle);
        const endEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
        const inner = endEdgeLabelLeft.insert("g").attr("class", "inner");
        fo = inner.node().appendChild(endLabelElement);
        const slBox = endLabelElement.getBBox();
        inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
        endEdgeLabelLeft.node().appendChild(endLabelElement);
        if (!terminalLabels[edge.id]) {
            terminalLabels[edge.id] = {};
        }
        terminalLabels[edge.id].endLeft = endEdgeLabelLeft;
        setTerminalWidth(fo, edge.endLabelLeft);
    }
    if (edge.endLabelRight) {
        const endLabelElement = createLabel$1(edge.endLabelRight, edge.labelStyle);
        const endEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
        const inner = endEdgeLabelRight.insert("g").attr("class", "inner");
        fo = inner.node().appendChild(endLabelElement);
        const slBox = endLabelElement.getBBox();
        inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
        endEdgeLabelRight.node().appendChild(endLabelElement);
        if (!terminalLabels[edge.id]) {
            terminalLabels[edge.id] = {};
        }
        terminalLabels[edge.id].endRight = endEdgeLabelRight;
        setTerminalWidth(fo, edge.endLabelRight);
    }
    return labelElement;
};
function setTerminalWidth(fo, value) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.htmlLabels && fo) {
        fo.style.width = value.length * 9 + "px";
        fo.style.height = "12px";
    }
}
const positionEdgeLabel = (edge, paths)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Moving label abc88 ", edge.id, edge.label, edgeLabels[edge.id], paths);
    let path = paths.updatedPath ? paths.updatedPath : paths.originalPath;
    const siteConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])();
    const { subGraphTitleTotalMargin } = getSubGraphTitleMargins(siteConfig);
    if (edge.label) {
        const el = edgeLabels[edge.id];
        let x = edge.x;
        let y = edge.y;
        if (path) {
            const pos = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"].calcLabelPosition(path);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Moving label " + edge.label + " from (", x, ",", y, ") to (", pos.x, ",", pos.y, ") abc88");
            if (paths.updatedPath) {
                x = pos.x;
                y = pos.y;
            }
        }
        el.attr("transform", `translate(${x}, ${y + subGraphTitleTotalMargin / 2})`);
    }
    if (edge.startLabelLeft) {
        const el = terminalLabels[edge.id].startLeft;
        let x = edge.x;
        let y = edge.y;
        if (path) {
            const pos = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"].calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, "start_left", path);
            x = pos.x;
            y = pos.y;
        }
        el.attr("transform", `translate(${x}, ${y})`);
    }
    if (edge.startLabelRight) {
        const el = terminalLabels[edge.id].startRight;
        let x = edge.x;
        let y = edge.y;
        if (path) {
            const pos = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"].calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, "start_right", path);
            x = pos.x;
            y = pos.y;
        }
        el.attr("transform", `translate(${x}, ${y})`);
    }
    if (edge.endLabelLeft) {
        const el = terminalLabels[edge.id].endLeft;
        let x = edge.x;
        let y = edge.y;
        if (path) {
            const pos = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"].calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_left", path);
            x = pos.x;
            y = pos.y;
        }
        el.attr("transform", `translate(${x}, ${y})`);
    }
    if (edge.endLabelRight) {
        const el = terminalLabels[edge.id].endRight;
        let x = edge.x;
        let y = edge.y;
        if (path) {
            const pos = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"].calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_right", path);
            x = pos.x;
            y = pos.y;
        }
        el.attr("transform", `translate(${x}, ${y})`);
    }
};
const outsideNode = (node, point2)=>{
    const x = node.x;
    const y = node.y;
    const dx = Math.abs(point2.x - x);
    const dy = Math.abs(point2.y - y);
    const w = node.width / 2;
    const h = node.height / 2;
    if (dx >= w || dy >= h) {
        return true;
    }
    return false;
};
const intersection = (node, outsidePoint, insidePoint)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(outsidePoint)}
  insidePoint : ${JSON.stringify(insidePoint)}
  node        : x:${node.x} y:${node.y} w:${node.width} h:${node.height}`);
    const x = node.x;
    const y = node.y;
    const dx = Math.abs(x - insidePoint.x);
    const w = node.width / 2;
    let r = insidePoint.x < outsidePoint.x ? w - dx : w + dx;
    const h = node.height / 2;
    const Q = Math.abs(outsidePoint.y - insidePoint.y);
    const R = Math.abs(outsidePoint.x - insidePoint.x);
    if (Math.abs(y - outsidePoint.y) * w > Math.abs(x - outsidePoint.x) * h) {
        let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y : y - h - outsidePoint.y;
        r = R * q / Q;
        const res = {
            x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,
            y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q
        };
        if (r === 0) {
            res.x = outsidePoint.x;
            res.y = outsidePoint.y;
        }
        if (R === 0) {
            res.x = outsidePoint.x;
        }
        if (Q === 0) {
            res.y = outsidePoint.y;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug(`abc89 topp/bott calc, Q ${Q}, q ${q}, R ${R}, r ${r}`, res);
        return res;
    } else {
        if (insidePoint.x < outsidePoint.x) {
            r = outsidePoint.x - w - x;
        } else {
            r = x - w - outsidePoint.x;
        }
        let q = Q * r / R;
        let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r;
        let _y = insidePoint.y < outsidePoint.y ? insidePoint.y + q : insidePoint.y - q;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug(`sides calc abc89, Q ${Q}, q ${q}, R ${R}, r ${r}`, {
            _x,
            _y
        });
        if (r === 0) {
            _x = outsidePoint.x;
            _y = outsidePoint.y;
        }
        if (R === 0) {
            _x = outsidePoint.x;
        }
        if (Q === 0) {
            _y = outsidePoint.y;
        }
        return {
            x: _x,
            y: _y
        };
    }
};
const cutPathAtIntersect = (_points, boundaryNode)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("abc88 cutPathAtIntersect", _points, boundaryNode);
    let points = [];
    let lastPointOutside = _points[0];
    let isInside = false;
    _points.forEach((point2)=>{
        if (!outsideNode(boundaryNode, point2) && !isInside) {
            const inter = intersection(boundaryNode, lastPointOutside, point2);
            let pointPresent = false;
            points.forEach((p)=>{
                pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;
            });
            if (!points.some((e)=>e.x === inter.x && e.y === inter.y)) {
                points.push(inter);
            }
            isInside = true;
        } else {
            lastPointOutside = point2;
            if (!isInside) {
                points.push(point2);
            }
        }
    });
    return points;
};
const insertEdge = function(elem, e, edge, clusterDb, diagramType, graph, id) {
    let points = edge.points;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("abc88 InsertEdge: edge=", edge, "e=", e);
    let pointsHasChanged = false;
    const tail = graph.node(e.v);
    var head = graph.node(e.w);
    if ((head == null ? void 0 : head.intersect) && (tail == null ? void 0 : tail.intersect)) {
        points = points.slice(1, edge.points.length - 1);
        points.unshift(tail.intersect(points[0]));
        points.push(head.intersect(points[points.length - 1]));
    }
    if (edge.toCluster) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("to cluster abc88", clusterDb[edge.toCluster]);
        points = cutPathAtIntersect(edge.points, clusterDb[edge.toCluster].node);
        pointsHasChanged = true;
    }
    if (edge.fromCluster) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("from cluster abc88", clusterDb[edge.fromCluster]);
        points = cutPathAtIntersect(points.reverse(), clusterDb[edge.fromCluster].node).reverse();
        pointsHasChanged = true;
    }
    const lineData = points.filter((p)=>!Number.isNaN(p.y));
    let curve = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$shape$2f$src$2f$curve$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__curveBasis$3e$__["curveBasis"];
    if (edge.curve && (diagramType === "graph" || diagramType === "flowchart")) {
        curve = edge.curve;
    }
    const { x, y } = getLineFunctionsWithOffset(edge);
    const lineFunction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$shape$2f$src$2f$line$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__line$3e$__["line"])().x(x).y(y).curve(curve);
    let strokeClasses;
    switch(edge.thickness){
        case "normal":
            strokeClasses = "edge-thickness-normal";
            break;
        case "thick":
            strokeClasses = "edge-thickness-thick";
            break;
        case "invisible":
            strokeClasses = "edge-thickness-thick";
            break;
        default:
            strokeClasses = "";
    }
    switch(edge.pattern){
        case "solid":
            strokeClasses += " edge-pattern-solid";
            break;
        case "dotted":
            strokeClasses += " edge-pattern-dotted";
            break;
        case "dashed":
            strokeClasses += " edge-pattern-dashed";
            break;
    }
    const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", edge.id).attr("class", " " + strokeClasses + (edge.classes ? " " + edge.classes : "")).attr("style", edge.style);
    let url = "";
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().flowchart.arrowMarkerAbsolute || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])().state.arrowMarkerAbsolute) {
        url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
        url = url.replace(/\(/g, "\\(");
        url = url.replace(/\)/g, "\\)");
    }
    addEdgeMarkers(svgPath, edge, url, id, diagramType);
    let paths = {};
    if (pointsHasChanged) {
        paths.updatedPath = points;
    }
    paths.originalPath = edge.points;
    return paths;
};
;
}}),
"[project]/node_modules/mermaid/dist/index-3862675e.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "r": (()=>render)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$dagre$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/dagre-d3-es/src/dagre/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$dagre$2f$layout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dagre-d3-es/src/dagre/layout.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dagre-d3-es/src/graphlib/json.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/edges-e0da2a9e.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/mermaid-b5860b54.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/dagre-d3-es/src/graphlib/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$graph$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dagre-d3-es/src/graphlib/graph.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$createText$2d$2e5e7dd3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/createText-2e5e7dd3.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/d3/src/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-selection/src/select.js [app-ssr] (ecmascript) <export default as select>");
;
;
;
;
;
;
;
let clusterDb = {};
let descendants = {};
let parents = {};
const clear$1 = ()=>{
    descendants = {};
    parents = {};
    clusterDb = {};
};
const isDescendant = (id, ancestorId)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("In isDescendant", ancestorId, " ", id, " = ", descendants[ancestorId].includes(id));
    if (descendants[ancestorId].includes(id)) {
        return true;
    }
    return false;
};
const edgeInCluster = (edge, clusterId)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Descendants of ", clusterId, " is ", descendants[clusterId]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Edge is ", edge);
    if (edge.v === clusterId) {
        return false;
    }
    if (edge.w === clusterId) {
        return false;
    }
    if (!descendants[clusterId]) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Tilt, ", clusterId, ",not in descendants");
        return false;
    }
    return descendants[clusterId].includes(edge.v) || isDescendant(edge.v, clusterId) || isDescendant(edge.w, clusterId) || descendants[clusterId].includes(edge.w);
};
const copy = (clusterId, graph, newGraph, rootId)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Copying children of ", clusterId, "root", rootId, "data", graph.node(clusterId), rootId);
    const nodes = graph.children(clusterId) || [];
    if (clusterId !== rootId) {
        nodes.push(clusterId);
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Copying (nodes) clusterId", clusterId, "nodes", nodes);
    nodes.forEach((node)=>{
        if (graph.children(node).length > 0) {
            copy(node, graph, newGraph, rootId);
        } else {
            const data = graph.node(node);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("cp ", node, " to ", rootId, " with parent ", clusterId);
            newGraph.setNode(node, data);
            if (rootId !== graph.parent(node)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Setting parent", node, graph.parent(node));
                newGraph.setParent(node, graph.parent(node));
            }
            if (clusterId !== rootId && node !== clusterId) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Setting parent", node, clusterId);
                newGraph.setParent(node, clusterId);
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("In copy ", clusterId, "root", rootId, "data", graph.node(clusterId), rootId);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Not Setting parent for node=", node, "cluster!==rootId", clusterId !== rootId, "node!==clusterId", node !== clusterId);
            }
            const edges = graph.edges(node);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Copying Edges", edges);
            edges.forEach((edge)=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Edge", edge);
                const data2 = graph.edge(edge.v, edge.w, edge.name);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Edge data", data2, rootId);
                try {
                    if (edgeInCluster(edge, rootId)) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Copying as ", edge.v, edge.w, data2, edge.name);
                        newGraph.setEdge(edge.v, edge.w, data2, edge.name);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("newGraph edges ", newGraph.edges(), newGraph.edge(newGraph.edges()[0]));
                    } else {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Skipping copy of edge ", edge.v, "-->", edge.w, " rootId: ", rootId, " clusterId:", clusterId);
                    }
                } catch (e) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].error(e);
                }
            });
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Removing node", node);
        graph.removeNode(node);
    });
};
const extractDescendants = (id, graph)=>{
    const children = graph.children(id);
    let res = [
        ...children
    ];
    for (const child of children){
        parents[child] = id;
        res = [
            ...res,
            ...extractDescendants(child, graph)
        ];
    }
    return res;
};
const findNonClusterChild = (id, graph)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Searching", id);
    const children = graph.children(id);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Searching children of id ", id, children);
    if (children.length < 1) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("This is a valid node", id);
        return id;
    }
    for (const child of children){
        const _id = findNonClusterChild(child, graph);
        if (_id) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Found replacement for", id, " => ", _id);
            return _id;
        }
    }
};
const getAnchorId = (id)=>{
    if (!clusterDb[id]) {
        return id;
    }
    if (!clusterDb[id].externalConnections) {
        return id;
    }
    if (clusterDb[id]) {
        return clusterDb[id].id;
    }
    return id;
};
const adjustClustersAndEdges = (graph, depth)=>{
    if (!graph || depth > 10) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Opting out, no graph ");
        return;
    } else {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Opting in, graph ");
    }
    graph.nodes().forEach(function(id) {
        const children = graph.children(id);
        if (children.length > 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Cluster identified", id, " Replacement id in edges: ", findNonClusterChild(id, graph));
            descendants[id] = extractDescendants(id, graph);
            clusterDb[id] = {
                id: findNonClusterChild(id, graph),
                clusterData: graph.node(id)
            };
        }
    });
    graph.nodes().forEach(function(id) {
        const children = graph.children(id);
        const edges = graph.edges();
        if (children.length > 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Cluster identified", id, descendants);
            edges.forEach((edge)=>{
                if (edge.v !== id && edge.w !== id) {
                    const d1 = isDescendant(edge.v, id);
                    const d2 = isDescendant(edge.w, id);
                    if (d1 ^ d2) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Edge: ", edge, " leaves cluster ", id);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Descendants of XXX ", id, ": ", descendants[id]);
                        clusterDb[id].externalConnections = true;
                    }
                }
            });
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Not a cluster ", id, descendants);
        }
    });
    for (let id of Object.keys(clusterDb)){
        const nonClusterChild = clusterDb[id].id;
        const parent = graph.parent(nonClusterChild);
        if (parent !== id && clusterDb[parent] && !clusterDb[parent].externalConnections) {
            clusterDb[id].id = parent;
        }
    }
    graph.edges().forEach(function(e) {
        const edge = graph.edge(e);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(graph.edge(e)));
        let v = e.v;
        let w = e.w;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Fix XXX", clusterDb, "ids:", e.v, e.w, "Translating: ", clusterDb[e.v], " --- ", clusterDb[e.w]);
        if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Fixing and trixing link to self - removing XXX", e.v, e.w, e.name);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
            v = getAnchorId(e.v);
            w = getAnchorId(e.w);
            graph.removeEdge(e.v, e.w, e.name);
            const specialId = e.w + "---" + e.v;
            graph.setNode(specialId, {
                domId: specialId,
                id: specialId,
                labelStyle: "",
                labelText: edge.label,
                padding: 0,
                shape: "labelRect",
                style: ""
            });
            const edge1 = structuredClone(edge);
            const edge2 = structuredClone(edge);
            edge1.label = "";
            edge1.arrowTypeEnd = "none";
            edge2.label = "";
            edge1.fromCluster = e.v;
            edge2.toCluster = e.v;
            graph.setEdge(v, specialId, edge1, e.name + "-cyclic-special");
            graph.setEdge(specialId, w, edge2, e.name + "-cyclic-special");
        } else if (clusterDb[e.v] || clusterDb[e.w]) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
            v = getAnchorId(e.v);
            w = getAnchorId(e.w);
            graph.removeEdge(e.v, e.w, e.name);
            if (v !== e.v) {
                const parent = graph.parent(v);
                clusterDb[parent].externalConnections = true;
                edge.fromCluster = e.v;
            }
            if (w !== e.w) {
                const parent = graph.parent(w);
                clusterDb[parent].externalConnections = true;
                edge.toCluster = e.w;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Fix Replacing with XXX", v, w, e.name);
            graph.setEdge(v, w, edge, e.name);
        }
    });
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Adjusted Graph", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(graph));
    extractor(graph, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace(clusterDb);
};
const extractor = (graph, depth)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("extractor - ", depth, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(graph), graph.children("D"));
    if (depth > 10) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].error("Bailing out");
        return;
    }
    let nodes = graph.nodes();
    let hasChildren = false;
    for (const node of nodes){
        const children = graph.children(node);
        hasChildren = hasChildren || children.length > 0;
    }
    if (!hasChildren) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Done, no node has children", graph.nodes());
        return;
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Nodes = ", nodes, depth);
    for (const node of nodes){
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Extracting node", node, clusterDb, clusterDb[node] && !clusterDb[node].externalConnections, !graph.parent(node), graph.node(node), graph.children("D"), " Depth ", depth);
        if (!clusterDb[node]) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Not a cluster", node, depth);
        } else if (!clusterDb[node].externalConnections && // !graph.parent(node) &&
        graph.children(node) && graph.children(node).length > 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Cluster without external connections, without a parent and with children", node, depth);
            const graphSettings = graph.graph();
            let dir = graphSettings.rankdir === "TB" ? "LR" : "TB";
            if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {
                dir = clusterDb[node].clusterData.dir;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Fixing dir", clusterDb[node].clusterData.dir, dir);
            }
            const clusterGraph = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$graph$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Graph"]({
                multigraph: true,
                compound: true
            }).setGraph({
                rankdir: dir,
                // Todo: set proper spacing
                nodesep: 50,
                ranksep: 50,
                marginx: 8,
                marginy: 8
            }).setDefaultEdgeLabel(function() {
                return {};
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Old graph before copy", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(graph));
            copy(node, graph, clusterGraph, node);
            graph.setNode(node, {
                clusterNode: true,
                id: node,
                clusterData: clusterDb[node].clusterData,
                labelText: clusterDb[node].labelText,
                graph: clusterGraph
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("New graph after copy node: (", node, ")", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(clusterGraph));
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug("Old graph after copy", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(graph));
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Cluster ** ", node, " **not meeting the criteria !externalConnections:", !clusterDb[node].externalConnections, " no parent: ", !graph.parent(node), " children ", graph.children(node) && graph.children(node).length > 0, graph.children("D"), depth);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug(clusterDb);
        }
    }
    nodes = graph.nodes();
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("New list of nodes", nodes);
    for (const node of nodes){
        const data = graph.node(node);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn(" Now next level", node, data);
        if (data.clusterNode) {
            extractor(data.graph, depth + 1);
        }
    }
};
const sorter = (graph, nodes)=>{
    if (nodes.length === 0) {
        return [];
    }
    let result = Object.assign(nodes);
    nodes.forEach((node)=>{
        const children = graph.children(node);
        const sorted = sorter(graph, children);
        result = [
            ...result,
            ...sorted
        ];
    });
    return result;
};
const sortNodesByHierarchy = (graph)=>sorter(graph, graph.children());
const rect = (parent, node)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Creating subgraph rect for ", node.id, node);
    const siteConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])();
    const shapeSvg = parent.insert("g").attr("class", "cluster" + (node.class ? " " + node.class : "")).attr("id", node.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const useHtmlLabels = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])(siteConfig.flowchart.htmlLabels);
    const label = shapeSvg.insert("g").attr("class", "cluster-label");
    const text = node.labelType === "markdown" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$createText$2d$2e5e7dd3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(label, node.labelText, {
        style: node.labelStyle,
        useHtmlLabels
    }) : label.node().appendChild((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(node.labelText, node.labelStyle, void 0, true));
    let bbox = text.getBBox();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])(siteConfig.flowchart.htmlLabels)) {
        const div = text.children[0];
        const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(text);
        bbox = div.getBoundingClientRect();
        dv.attr("width", bbox.width);
        dv.attr("height", bbox.height);
    }
    const padding = 0 * node.padding;
    const halfPadding = padding / 2;
    const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;
    if (node.width <= bbox.width + padding) {
        node.diff = (bbox.width - node.width) / 2 - node.padding / 2;
    } else {
        node.diff = -node.padding / 2;
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Data ", node, JSON.stringify(node));
    rect2.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("x", node.x - width / 2).attr("y", node.y - node.height / 2 - halfPadding).attr("width", width).attr("height", node.height + padding);
    const { subGraphTitleTopMargin } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])(siteConfig);
    if (useHtmlLabels) {
        label.attr("transform", // This puts the label on top of the box instead of inside it
        `translate(${node.x - bbox.width / 2}, ${node.y - node.height / 2 + subGraphTitleTopMargin})`);
    } else {
        label.attr("transform", // This puts the label on top of the box instead of inside it
        `translate(${node.x}, ${node.y - node.height / 2 + subGraphTitleTopMargin})`);
    }
    const rectBox = rect2.node().getBBox();
    node.width = rectBox.width;
    node.height = rectBox.height;
    node.intersect = function(point) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"])(node, point);
    };
    return shapeSvg;
};
const noteGroup = (parent, node)=>{
    const shapeSvg = parent.insert("g").attr("class", "note-cluster").attr("id", node.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const padding = 0 * node.padding;
    const halfPadding = padding / 2;
    rect2.attr("rx", node.rx).attr("ry", node.ry).attr("x", node.x - node.width / 2 - halfPadding).attr("y", node.y - node.height / 2 - halfPadding).attr("width", node.width + padding).attr("height", node.height + padding).attr("fill", "none");
    const rectBox = rect2.node().getBBox();
    node.width = rectBox.width;
    node.height = rectBox.height;
    node.intersect = function(point) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"])(node, point);
    };
    return shapeSvg;
};
const roundedWithTitle = (parent, node)=>{
    const siteConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])();
    const shapeSvg = parent.insert("g").attr("class", node.classes).attr("id", node.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const label = shapeSvg.insert("g").attr("class", "cluster-label");
    const innerRect = shapeSvg.append("rect");
    const text = label.node().appendChild((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(node.labelText, node.labelStyle, void 0, true));
    let bbox = text.getBBox();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])(siteConfig.flowchart.htmlLabels)) {
        const div = text.children[0];
        const dv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(text);
        bbox = div.getBoundingClientRect();
        dv.attr("width", bbox.width);
        dv.attr("height", bbox.height);
    }
    bbox = text.getBBox();
    const padding = 0 * node.padding;
    const halfPadding = padding / 2;
    const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;
    if (node.width <= bbox.width + node.padding) {
        node.diff = (bbox.width + node.padding * 0 - node.width) / 2;
    } else {
        node.diff = -node.padding / 2;
    }
    rect2.attr("class", "outer").attr("x", node.x - width / 2 - halfPadding).attr("y", node.y - node.height / 2 - halfPadding).attr("width", width + padding).attr("height", node.height + padding);
    innerRect.attr("class", "inner").attr("x", node.x - width / 2 - halfPadding).attr("y", node.y - node.height / 2 - halfPadding + bbox.height - 1).attr("width", width + padding).attr("height", node.height + padding - bbox.height - 3);
    const { subGraphTitleTopMargin } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])(siteConfig);
    label.attr("transform", `translate(${node.x - bbox.width / 2}, ${node.y - node.height / 2 - node.padding / 3 + ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])(siteConfig.flowchart.htmlLabels) ? 5 : 3) + subGraphTitleTopMargin})`);
    const rectBox = rect2.node().getBBox();
    node.height = rectBox.height;
    node.intersect = function(point) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"])(node, point);
    };
    return shapeSvg;
};
const divider = (parent, node)=>{
    const shapeSvg = parent.insert("g").attr("class", node.classes).attr("id", node.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const padding = 0 * node.padding;
    const halfPadding = padding / 2;
    rect2.attr("class", "divider").attr("x", node.x - node.width / 2 - halfPadding).attr("y", node.y - node.height / 2).attr("width", node.width + padding).attr("height", node.height + padding);
    const rectBox = rect2.node().getBBox();
    node.width = rectBox.width;
    node.height = rectBox.height;
    node.diff = -node.padding / 2;
    node.intersect = function(point) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"])(node, point);
    };
    return shapeSvg;
};
const shapes = {
    rect,
    roundedWithTitle,
    noteGroup,
    divider
};
let clusterElems = {};
const insertCluster = (elem, node)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Inserting cluster");
    const shape = node.shape || "rect";
    clusterElems[node.id] = shapes[shape](elem, node);
};
const clear = ()=>{
    clusterElems = {};
};
const recursiveRender = async (_elem, graph, diagramType, id, parentCluster, siteConfig)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Graph in recursive render: XXX", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(graph), parentCluster);
    const dir = graph.graph().rankdir;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Dir in recursive render - dir:", dir);
    const elem = _elem.insert("g").attr("class", "root");
    if (!graph.nodes()) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("No nodes found for", graph);
    } else {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Recursive render XXX", graph.nodes());
    }
    if (graph.edges().length > 0) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Recursive edges", graph.edge(graph.edges()[0]));
    }
    const clusters = elem.insert("g").attr("class", "clusters");
    const edgePaths = elem.insert("g").attr("class", "edgePaths");
    const edgeLabels = elem.insert("g").attr("class", "edgeLabels");
    const nodes = elem.insert("g").attr("class", "nodes");
    await Promise.all(graph.nodes().map(async function(v) {
        const node = graph.node(v);
        if (parentCluster !== void 0) {
            const data = JSON.parse(JSON.stringify(parentCluster.clusterData));
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Setting data for cluster XXX (", v, ") ", data, parentCluster);
            graph.setNode(parentCluster.id, data);
            if (!graph.parent(v)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Setting parent", v, parentCluster.id);
                graph.setParent(v, parentCluster.id, data);
            }
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("(Insert) Node XXX" + v + ": " + JSON.stringify(graph.node(v)));
        if (node && node.clusterNode) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Cluster identified", v, node.width, graph.node(v));
            const o = await recursiveRender(nodes, node.graph, diagramType, id, graph.node(v), siteConfig);
            const newEl = o.elem;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"])(node, newEl);
            node.diff = o.diff || 0;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Node bounds (abc123)", v, node, node.width, node.x, node.y);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"])(newEl, node);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Recursive render complete ", newEl, node);
        } else {
            if (graph.children(v).length > 0) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Cluster - the non recursive path XXX", v, node.id, node, graph);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info(findNonClusterChild(node.id, graph));
                clusterDb[node.id] = {
                    id: findNonClusterChild(node.id, graph),
                    node
                };
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Node - the non recursive path", v, node.id, node);
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(nodes, graph.node(v), dir);
            }
        }
    }));
    graph.edges().forEach(function(e) {
        const edge = graph.edge(e.v, e.w, e.name);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Edge " + e.v + " -> " + e.w + ": ", e, " ", JSON.stringify(graph.edge(e)));
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Fix", clusterDb, "ids:", e.v, e.w, "Translating: ", clusterDb[e.v], clusterDb[e.w]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"])(edgeLabels, edge);
    });
    graph.edges().forEach(function(e) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
    });
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("#############################################");
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("###                Layout                 ###");
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("#############################################");
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info(graph);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$dagre$2f$layout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["layout"])(graph);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Graph after layout:", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(graph));
    let diff = 0;
    const { subGraphTitleTotalMargin } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])(siteConfig);
    sortNodesByHierarchy(graph).forEach(function(v) {
        const node = graph.node(v);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Position " + v + ": " + JSON.stringify(graph.node(v)));
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Position " + v + ": (" + node.x, "," + node.y, ") width: ", node.width, " height: ", node.height);
        if (node && node.clusterNode) {
            node.y += subGraphTitleTotalMargin;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(node);
        } else {
            if (graph.children(v).length > 0) {
                node.height += subGraphTitleTotalMargin;
                insertCluster(clusters, node);
                clusterDb[node.id].node = node;
            } else {
                node.y += subGraphTitleTotalMargin / 2;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(node);
            }
        }
    });
    graph.edges().forEach(function(e) {
        const edge = graph.edge(e);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(edge), edge);
        edge.points.forEach((point)=>point.y += subGraphTitleTotalMargin / 2);
        const paths = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["h"])(edgePaths, e, edge, clusterDb, diagramType, graph, id);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["j"])(edge, paths);
    });
    graph.nodes().forEach(function(v) {
        const n = graph.node(v);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info(v, n.type, n.diff);
        if (n.type === "group") {
            diff = n.diff;
        }
    });
    return {
        elem,
        diff
    };
};
const render = async (elem, graph, markers, diagramType, id)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(elem, markers, diagramType, id);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$edges$2d$e0da2a9e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])();
    clear();
    clear$1();
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Graph at first:", JSON.stringify((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(graph)));
    adjustClustersAndEdges(graph);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn("Graph after:", JSON.stringify((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["write"])(graph)));
    const siteConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])();
    await recursiveRender(elem, graph, diagramType, id, void 0, siteConfig);
};
;
}}),
"[project]/node_modules/mermaid/dist/stateDiagram-v2-d93cdb3a.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "diagram": (()=>diagram)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/styles-6aaf32cf.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/dagre-d3-es/src/graphlib/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$graph$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dagre-d3-es/src/graphlib/graph.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/d3/src/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-selection/src/select.js [app-ssr] (ecmascript) <export default as select>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/mermaid-b5860b54.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$index$2d$3862675e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/index-3862675e.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ts$2d$dedent$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ts-dedent/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dayjs$2f$dayjs$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dayjs/dayjs.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$braintree$2f$sanitize$2d$url$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@braintree/sanitize-url/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dompurify$2f$dist$2f$purify$2e$es$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dompurify/dist/purify.es.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$dagre$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/dagre-d3-es/src/dagre/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dagre-d3-es/src/graphlib/json.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const SHAPE_STATE = "rect";
const SHAPE_STATE_WITH_DESC = "rectWithTitle";
const SHAPE_START = "start";
const SHAPE_END = "end";
const SHAPE_DIVIDER = "divider";
const SHAPE_GROUP = "roundedWithTitle";
const SHAPE_NOTE = "note";
const SHAPE_NOTEGROUP = "noteGroup";
const CSS_DIAGRAM = "statediagram";
const CSS_STATE = "state";
const CSS_DIAGRAM_STATE = `${CSS_DIAGRAM}-${CSS_STATE}`;
const CSS_EDGE = "transition";
const CSS_NOTE = "note";
const CSS_NOTE_EDGE = "note-edge";
const CSS_EDGE_NOTE_EDGE = `${CSS_EDGE} ${CSS_NOTE_EDGE}`;
const CSS_DIAGRAM_NOTE = `${CSS_DIAGRAM}-${CSS_NOTE}`;
const CSS_CLUSTER = "cluster";
const CSS_DIAGRAM_CLUSTER = `${CSS_DIAGRAM}-${CSS_CLUSTER}`;
const CSS_CLUSTER_ALT = "cluster-alt";
const CSS_DIAGRAM_CLUSTER_ALT = `${CSS_DIAGRAM}-${CSS_CLUSTER_ALT}`;
const PARENT = "parent";
const NOTE = "note";
const DOMID_STATE = "state";
const DOMID_TYPE_SPACER = "----";
const NOTE_ID = `${DOMID_TYPE_SPACER}${NOTE}`;
const PARENT_ID = `${DOMID_TYPE_SPACER}${PARENT}`;
const G_EDGE_STYLE = "fill:none";
const G_EDGE_ARROWHEADSTYLE = "fill: #333";
const G_EDGE_LABELPOS = "c";
const G_EDGE_LABELTYPE = "text";
const G_EDGE_THICKNESS = "normal";
let nodeDb = {};
let graphItemCount = 0;
const setConf = function(cnf) {
    const keys = Object.keys(cnf);
    for (const key of keys){
        cnf[key];
    }
};
const getClasses = function(text, diagramObj) {
    diagramObj.db.extract(diagramObj.db.getRootDocV2());
    return diagramObj.db.getClasses();
};
function getClassesFromDbInfo(dbInfoItem) {
    if (dbInfoItem === void 0 || dbInfoItem === null) {
        return "";
    } else {
        if (dbInfoItem.classes) {
            return dbInfoItem.classes.join(" ");
        } else {
            return "";
        }
    }
}
function stateDomId(itemId = "", counter = 0, type = "", typeSpacer = DOMID_TYPE_SPACER) {
    const typeStr = type !== null && type.length > 0 ? `${typeSpacer}${type}` : "";
    return `${DOMID_STATE}-${itemId}${typeStr}-${counter}`;
}
const setupNode = (g, parent, parsedItem, diagramStates, diagramDb, altFlag)=>{
    const itemId = parsedItem.id;
    const classStr = getClassesFromDbInfo(diagramStates[itemId]);
    if (itemId !== "root") {
        let shape = SHAPE_STATE;
        if (parsedItem.start === true) {
            shape = SHAPE_START;
        }
        if (parsedItem.start === false) {
            shape = SHAPE_END;
        }
        if (parsedItem.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["D"]) {
            shape = parsedItem.type;
        }
        if (!nodeDb[itemId]) {
            nodeDb[itemId] = {
                id: itemId,
                shape,
                description: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"].sanitizeText(itemId, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])()),
                classes: `${classStr} ${CSS_DIAGRAM_STATE}`
            };
        }
        const newNode = nodeDb[itemId];
        if (parsedItem.description) {
            if (Array.isArray(newNode.description)) {
                newNode.shape = SHAPE_STATE_WITH_DESC;
                newNode.description.push(parsedItem.description);
            } else {
                if (newNode.description.length > 0) {
                    newNode.shape = SHAPE_STATE_WITH_DESC;
                    if (newNode.description === itemId) {
                        newNode.description = [
                            parsedItem.description
                        ];
                    } else {
                        newNode.description = [
                            newNode.description,
                            parsedItem.description
                        ];
                    }
                } else {
                    newNode.shape = SHAPE_STATE;
                    newNode.description = parsedItem.description;
                }
            }
            newNode.description = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"].sanitizeTextOrArray(newNode.description, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])());
        }
        if (newNode.description.length === 1 && newNode.shape === SHAPE_STATE_WITH_DESC) {
            newNode.shape = SHAPE_STATE;
        }
        if (!newNode.type && parsedItem.doc) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Setting cluster for ", itemId, getDir(parsedItem));
            newNode.type = "group";
            newNode.dir = getDir(parsedItem);
            newNode.shape = parsedItem.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"] ? SHAPE_DIVIDER : SHAPE_GROUP;
            newNode.classes = newNode.classes + " " + CSS_DIAGRAM_CLUSTER + " " + (altFlag ? CSS_DIAGRAM_CLUSTER_ALT : "");
        }
        const nodeData = {
            labelStyle: "",
            shape: newNode.shape,
            labelText: newNode.description,
            // typeof newNode.description === 'object'
            //   ? newNode.description[0]
            //   : newNode.description,
            classes: newNode.classes,
            style: "",
            //styles.style,
            id: itemId,
            dir: newNode.dir,
            domId: stateDomId(itemId, graphItemCount),
            type: newNode.type,
            padding: 15
        };
        nodeData.centerLabel = true;
        if (parsedItem.note) {
            const noteData = {
                labelStyle: "",
                shape: SHAPE_NOTE,
                labelText: parsedItem.note.text,
                classes: CSS_DIAGRAM_NOTE,
                // useHtmlLabels: false,
                style: "",
                // styles.style,
                id: itemId + NOTE_ID + "-" + graphItemCount,
                domId: stateDomId(itemId, graphItemCount, NOTE),
                type: newNode.type,
                padding: 15
            };
            const groupData = {
                labelStyle: "",
                shape: SHAPE_NOTEGROUP,
                labelText: parsedItem.note.text,
                classes: newNode.classes,
                style: "",
                // styles.style,
                id: itemId + PARENT_ID,
                domId: stateDomId(itemId, graphItemCount, PARENT),
                type: "group",
                padding: 0
            };
            graphItemCount++;
            const parentNodeId = itemId + PARENT_ID;
            g.setNode(parentNodeId, groupData);
            g.setNode(noteData.id, noteData);
            g.setNode(itemId, nodeData);
            g.setParent(itemId, parentNodeId);
            g.setParent(noteData.id, parentNodeId);
            let from = itemId;
            let to = noteData.id;
            if (parsedItem.note.position === "left of") {
                from = noteData.id;
                to = itemId;
            }
            g.setEdge(from, to, {
                arrowhead: "none",
                arrowType: "",
                style: G_EDGE_STYLE,
                labelStyle: "",
                classes: CSS_EDGE_NOTE_EDGE,
                arrowheadStyle: G_EDGE_ARROWHEADSTYLE,
                labelpos: G_EDGE_LABELPOS,
                labelType: G_EDGE_LABELTYPE,
                thickness: G_EDGE_THICKNESS
            });
        } else {
            g.setNode(itemId, nodeData);
        }
    }
    if (parent && parent.id !== "root") {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Setting node ", itemId, " to be child of its parent ", parent.id);
        g.setParent(itemId, parent.id);
    }
    if (parsedItem.doc) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("Adding nodes children ");
        setupDoc(g, parsedItem, parsedItem.doc, diagramStates, diagramDb, !altFlag);
    }
};
const setupDoc = (g, parentParsedItem, doc, diagramStates, diagramDb, altFlag)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].trace("items", doc);
    doc.forEach((item)=>{
        switch(item.stmt){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"]:
                setupNode(g, parentParsedItem, item, diagramStates, diagramDb, altFlag);
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["D"]:
                setupNode(g, parentParsedItem, item, diagramStates, diagramDb, altFlag);
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"]:
                {
                    setupNode(g, parentParsedItem, item.state1, diagramStates, diagramDb, altFlag);
                    setupNode(g, parentParsedItem, item.state2, diagramStates, diagramDb, altFlag);
                    const edgeData = {
                        id: "edge" + graphItemCount,
                        arrowhead: "normal",
                        arrowTypeEnd: "arrow_barb",
                        style: G_EDGE_STYLE,
                        labelStyle: "",
                        label: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"].sanitizeText(item.description, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])()),
                        arrowheadStyle: G_EDGE_ARROWHEADSTYLE,
                        labelpos: G_EDGE_LABELPOS,
                        labelType: G_EDGE_LABELTYPE,
                        thickness: G_EDGE_THICKNESS,
                        classes: CSS_EDGE
                    };
                    g.setEdge(item.state1.id, item.state2.id, edgeData, graphItemCount);
                    graphItemCount++;
                }
                break;
        }
    });
};
const getDir = (parsedItem, defaultDir = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])=>{
    let dir = defaultDir;
    if (parsedItem.doc) {
        for(let i = 0; i < parsedItem.doc.length; i++){
            const parsedItemDoc = parsedItem.doc[i];
            if (parsedItemDoc.stmt === "dir") {
                dir = parsedItemDoc.value;
            }
        }
    }
    return dir;
};
const draw = async function(text, id, _version, diag) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info("Drawing state diagram (v2)", id);
    nodeDb = {};
    diag.db.getDirection();
    const { securityLevel, state: conf } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])();
    const nodeSpacing = conf.nodeSpacing || 50;
    const rankSpacing = conf.rankSpacing || 50;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info(diag.db.getRootDocV2());
    diag.db.extract(diag.db.getRootDocV2());
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].info(diag.db.getRootDocV2());
    const diagramStates = diag.db.getStates();
    const g = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dagre$2d$d3$2d$es$2f$src$2f$graphlib$2f$graph$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Graph"]({
        multigraph: true,
        compound: true
    }).setGraph({
        rankdir: getDir(diag.db.getRootDocV2()),
        nodesep: nodeSpacing,
        ranksep: rankSpacing,
        marginx: 8,
        marginy: 8
    }).setDefaultEdgeLabel(function() {
        return {};
    });
    setupNode(g, void 0, diag.db.getRootDocV2(), diagramStates, diag.db, true);
    let sandboxElement;
    if (securityLevel === "sandbox") {
        sandboxElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])("#i" + id);
    }
    const root = securityLevel === "sandbox" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])(sandboxElement.nodes()[0].contentDocument.body) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])("body");
    const svg = root.select(`[id="${id}"]`);
    const element = root.select("#" + id + " g");
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$index$2d$3862675e$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"])(element, g, [
        "barb"
    ], CSS_DIAGRAM, id);
    const padding = 8;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"].insertTitle(svg, "statediagramTitleText", conf.titleTopMargin, diag.db.getDiagramTitle());
    const bounds = svg.node().getBBox();
    const width = bounds.width + padding * 2;
    const height = bounds.height + padding * 2;
    svg.attr("class", CSS_DIAGRAM);
    const svgBounds = svg.node().getBBox();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"])(svg, height, width, conf.useMaxWidth);
    const vBox = `${svgBounds.x - padding} ${svgBounds.y - padding} ${width} ${height}`;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$mermaid$2d$b5860b54$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].debug(`viewBox ${vBox}`);
    svg.attr("viewBox", vBox);
    const labels = document.querySelectorAll('[id="' + id + '"] .edgeLabel .label');
    for (const label of labels){
        const dim = label.getBBox();
        const rect = document.createElementNS("http://www.w3.org/2000/svg", SHAPE_STATE);
        rect.setAttribute("rx", 0);
        rect.setAttribute("ry", 0);
        rect.setAttribute("width", dim.width);
        rect.setAttribute("height", dim.height);
        label.insertBefore(rect, label.firstChild);
    }
};
const renderer = {
    setConf,
    getClasses,
    draw
};
const diagram = {
    parser: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"],
    db: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"],
    renderer,
    styles: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"],
    init: (cnf)=>{
        if (!cnf.state) {
            cnf.state = {};
        }
        cnf.state.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$styles$2d$6aaf32cf$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"].clear();
    }
};
;
}}),

};

//# sourceMappingURL=node_modules_mermaid_dist_b90174cb._.js.map