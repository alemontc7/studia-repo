(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_ffa4ff5d._.js", {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray;
    new ("function" === typeof WeakMap ? WeakMap : Map)();
    var createTask = console.createTask ? console.createTask : function() {
        return null;
    }, specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, Error("react-stack-top-frame"), createTask(getTaskName(type)));
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "BailoutToCSR", {
    enumerable: true,
    get: function() {
        return BailoutToCSR;
    }
});
const _bailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)");
function BailoutToCSR(param) {
    let { reason, children } = param;
    if (typeof window === 'undefined') {
        throw Object.defineProperty(new _bailouttocsr.BailoutToCSRError(reason), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    return children;
} //# sourceMappingURL=dynamic-bailout-to-csr.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/encode-uri-path.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "encodeURIPath", {
    enumerable: true,
    get: function() {
        return encodeURIPath;
    }
});
function encodeURIPath(file) {
    return file.split('/').map((p)=>encodeURIComponent(p)).join('/');
} //# sourceMappingURL=encode-uri-path.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/preload-chunks.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "PreloadChunks", {
    enumerable: true,
    get: function() {
        return PreloadChunks;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _reactdom = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
const _encodeuripath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/encode-uri-path.js [app-client] (ecmascript)");
function PreloadChunks(param) {
    let { moduleIds } = param;
    // Early return in client compilation and only load requestStore on server side
    if (typeof window !== 'undefined') {
        return null;
    }
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    if (workStore === undefined) {
        return null;
    }
    const allFiles = [];
    // Search the current dynamic call unique key id in react loadable manifest,
    // and find the corresponding CSS files to preload
    if (workStore.reactLoadableManifest && moduleIds) {
        const manifest = workStore.reactLoadableManifest;
        for (const key of moduleIds){
            if (!manifest[key]) continue;
            const chunks = manifest[key].files;
            allFiles.push(...chunks);
        }
    }
    if (allFiles.length === 0) {
        return null;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: allFiles.map((chunk)=>{
            const href = workStore.assetPrefix + "/_next/" + (0, _encodeuripath.encodeURIPath)(chunk);
            const isCss = chunk.endsWith('.css');
            // If it's stylesheet we use `precedence` o help hoist with React Float.
            // For stylesheets we actually need to render the CSS because nothing else is going to do it so it needs to be part of the component tree.
            // The `preload` for stylesheet is not optional.
            if (isCss) {
                return /*#__PURE__*/ (0, _jsxruntime.jsx)("link", {
                    // @ts-ignore
                    precedence: "dynamic",
                    href: href,
                    rel: "stylesheet",
                    as: "style"
                }, chunk);
            } else {
                // If it's script we use ReactDOM.preload to preload the resources
                (0, _reactdom.preload)(href, {
                    as: 'script',
                    fetchPriority: 'low'
                });
                return null;
            }
        })
    });
} //# sourceMappingURL=preload-chunks.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _dynamicbailouttocsr = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js [app-client] (ecmascript)");
const _preloadchunks = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/preload-chunks.js [app-client] (ecmascript)");
// Normalize loader to return the module as form { default: Component } for `React.lazy`.
// Also for backward compatible since next/dynamic allows to resolve a component directly with loader
// Client component reference proxy need to be converted to a module.
function convertModule(mod) {
    // Check "default" prop before accessing it, as it could be client reference proxy that could break it reference.
    // Cases:
    // mod: { default: Component }
    // mod: Component
    // mod: { default: proxy(Component) }
    // mod: proxy(Component)
    const hasDefault = mod && 'default' in mod;
    return {
        default: hasDefault ? mod.default : mod
    };
}
const defaultOptions = {
    loader: ()=>Promise.resolve(convertModule(()=>null)),
    loading: null,
    ssr: true
};
function Loadable(options) {
    const opts = {
        ...defaultOptions,
        ...options
    };
    const Lazy = /*#__PURE__*/ (0, _react.lazy)(()=>opts.loader().then(convertModule));
    const Loading = opts.loading;
    function LoadableComponent(props) {
        const fallbackElement = Loading ? /*#__PURE__*/ (0, _jsxruntime.jsx)(Loading, {
            isLoading: true,
            pastDelay: true,
            error: null
        }) : null;
        // If it's non-SSR or provided a loading component, wrap it in a suspense boundary
        const hasSuspenseBoundary = !opts.ssr || !!opts.loading;
        const Wrap = hasSuspenseBoundary ? _react.Suspense : _react.Fragment;
        const wrapProps = hasSuspenseBoundary ? {
            fallback: fallbackElement
        } : {};
        const children = opts.ssr ? /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
                typeof window === 'undefined' ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_preloadchunks.PreloadChunks, {
                    moduleIds: opts.modules
                }) : null,
                /*#__PURE__*/ (0, _jsxruntime.jsx)(Lazy, {
                    ...props
                })
            ]
        }) : /*#__PURE__*/ (0, _jsxruntime.jsx)(_dynamicbailouttocsr.BailoutToCSR, {
            reason: "next/dynamic",
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Lazy, {
                ...props
            })
        });
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Wrap, {
            ...wrapProps,
            children: children
        });
    }
    LoadableComponent.displayName = 'LoadableComponent';
    return LoadableComponent;
}
const _default = Loadable; //# sourceMappingURL=loadable.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/app-dynamic.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return dynamic;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/next/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _loadable = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js [app-client] (ecmascript)"));
function dynamic(dynamicOptions, options) {
    var _mergedOptions_loadableGenerated;
    const loadableOptions = {};
    if (typeof dynamicOptions === 'function') {
        loadableOptions.loader = dynamicOptions;
    }
    const mergedOptions = {
        ...loadableOptions,
        ...options
    };
    return (0, _loadable.default)({
        ...mergedOptions,
        modules: (_mergedOptions_loadableGenerated = mergedOptions.loadableGenerated) == null ? void 0 : _mergedOptions_loadableGenerated.modules
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-dynamic.js.map
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/constants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DEFAULT_FONT_SIZE": (()=>DEFAULT_FONT_SIZE),
    "MERMAID_CONFIG": (()=>MERMAID_CONFIG),
    "SVG_TO_SHAPE_MAPPER": (()=>SVG_TO_SHAPE_MAPPER)
});
const DEFAULT_FONT_SIZE = 20;
const SVG_TO_SHAPE_MAPPER = {
    rect: "rectangle",
    circle: "ellipse"
};
const MERMAID_CONFIG = {
    startOnLoad: false,
    flowchart: {
        curve: "linear"
    },
    themeVariables: {
        // Multiplying by 1.25 to increase the font size by 25% and render correctly in Excalidraw
        fontSize: `${DEFAULT_FONT_SIZE * 1.25}px`
    },
    maxEdges: 500,
    maxTextSize: 50000
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/GraphConverter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GraphConverter": (()=>GraphConverter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/constants.js [app-client] (ecmascript)");
;
class GraphConverter {
    constructor({ converter }){
        this.convert = (graph, config)=>{
            return this.converter(graph, {
                ...config,
                fontSize: config.fontSize || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONT_SIZE"]
            });
        };
        this.converter = converter;
    }
}
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/interfaces.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CONTAINER_STYLE_PROPERTY": (()=>CONTAINER_STYLE_PROPERTY),
    "LABEL_STYLE_PROPERTY": (()=>LABEL_STYLE_PROPERTY),
    "VERTEX_TYPE": (()=>VERTEX_TYPE)
});
var VERTEX_TYPE;
(function(VERTEX_TYPE) {
    VERTEX_TYPE["ROUND"] = "round";
    VERTEX_TYPE["STADIUM"] = "stadium";
    VERTEX_TYPE["DOUBLECIRCLE"] = "doublecircle";
    VERTEX_TYPE["CIRCLE"] = "circle";
    VERTEX_TYPE["DIAMOND"] = "diamond";
})(VERTEX_TYPE || (VERTEX_TYPE = {}));
var LABEL_STYLE_PROPERTY;
(function(LABEL_STYLE_PROPERTY) {
    LABEL_STYLE_PROPERTY["COLOR"] = "color";
})(LABEL_STYLE_PROPERTY || (LABEL_STYLE_PROPERTY = {}));
var CONTAINER_STYLE_PROPERTY;
(function(CONTAINER_STYLE_PROPERTY) {
    CONTAINER_STYLE_PROPERTY["FILL"] = "fill";
    CONTAINER_STYLE_PROPERTY["STROKE"] = "stroke";
    CONTAINER_STYLE_PROPERTY["STROKE_WIDTH"] = "stroke-width";
    CONTAINER_STYLE_PROPERTY["STROKE_DASHARRAY"] = "stroke-dasharray";
})(CONTAINER_STYLE_PROPERTY || (CONTAINER_STYLE_PROPERTY = {}));
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/helpers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "computeExcalidrawArrowType": (()=>computeExcalidrawArrowType),
    "computeExcalidrawVertexLabelStyle": (()=>computeExcalidrawVertexLabelStyle),
    "computeExcalidrawVertexStyle": (()=>computeExcalidrawVertexStyle),
    "getText": (()=>getText)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/interfaces.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$markdown$2d$to$2d$text$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/markdown-to-text/dist/index.js [app-client] (ecmascript)");
;
;
/**
 * Convert mermaid edge type to Excalidraw arrow type
 */ const MERMAID_EDGE_TYPE_MAPPER = {
    arrow_circle: {
        endArrowhead: "dot"
    },
    arrow_cross: {
        endArrowhead: "bar"
    },
    arrow_open: {
        endArrowhead: null,
        startArrowhead: null
    },
    double_arrow_circle: {
        endArrowhead: "dot",
        startArrowhead: "dot"
    },
    double_arrow_cross: {
        endArrowhead: "bar",
        startArrowhead: "bar"
    },
    double_arrow_point: {
        endArrowhead: "arrow",
        startArrowhead: "arrow"
    }
};
const computeExcalidrawArrowType = (mermaidArrowType)=>{
    return MERMAID_EDGE_TYPE_MAPPER[mermaidArrowType];
};
const getText = (element)=>{
    let text = element.text;
    if (element.labelType === "markdown") {
        text = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$markdown$2d$to$2d$text$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removeMarkdown"])(element.text);
    }
    return removeFontAwesomeIcons(text);
};
/**
 * Remove font awesome icons support from text
 */ const removeFontAwesomeIcons = (input)=>{
    const fontAwesomeRegex = /\s?(fa|fab):[a-zA-Z0-9-]+/g;
    return input.replace(fontAwesomeRegex, "");
};
const computeExcalidrawVertexStyle = (style)=>{
    const excalidrawProperty = {};
    Object.keys(style).forEach((property)=>{
        switch(property){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CONTAINER_STYLE_PROPERTY"].FILL:
                {
                    excalidrawProperty.backgroundColor = style[property];
                    excalidrawProperty.fillStyle = "solid";
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CONTAINER_STYLE_PROPERTY"].STROKE:
                {
                    excalidrawProperty.strokeColor = style[property];
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CONTAINER_STYLE_PROPERTY"].STROKE_WIDTH:
                {
                    excalidrawProperty.strokeWidth = Number(style[property]?.split("px")[0]);
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CONTAINER_STYLE_PROPERTY"].STROKE_DASHARRAY:
                {
                    excalidrawProperty.strokeStyle = "dashed";
                    break;
                }
        }
    });
    return excalidrawProperty;
};
const computeExcalidrawVertexLabelStyle = (style)=>{
    const excalidrawProperty = {};
    Object.keys(style).forEach((property)=>{
        switch(property){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_STYLE_PROPERTY"].COLOR:
                {
                    excalidrawProperty.strokeColor = style[property];
                    break;
                }
        }
    });
    return excalidrawProperty;
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/flowchart.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "FlowchartToExcalidrawSkeletonConverter": (()=>FlowchartToExcalidrawSkeletonConverter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$GraphConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/GraphConverter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/helpers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/interfaces.js [app-client] (ecmascript)");
;
;
;
const computeGroupIds = (graph)=>{
    // Parse the diagram into a tree for rendering and grouping
    const tree = {};
    graph.subGraphs.map((subGraph)=>{
        subGraph.nodeIds.forEach((nodeId)=>{
            tree[subGraph.id] = {
                id: subGraph.id,
                parent: null,
                isLeaf: false
            };
            tree[nodeId] = {
                id: nodeId,
                parent: subGraph.id,
                isLeaf: graph.vertices[nodeId] !== undefined
            };
        });
    });
    const mapper = {};
    [
        ...Object.keys(graph.vertices),
        ...graph.subGraphs.map((c)=>c.id)
    ].forEach((id)=>{
        if (!tree[id]) {
            return;
        }
        let curr = tree[id];
        const groupIds = [];
        if (!curr.isLeaf) {
            groupIds.push(`subgraph_group_${curr.id}`);
        }
        while(true){
            if (curr.parent) {
                groupIds.push(`subgraph_group_${curr.parent}`);
                curr = tree[curr.parent];
            } else {
                break;
            }
        }
        mapper[id] = groupIds;
    });
    return {
        getGroupIds: (elementId)=>{
            return mapper[elementId] || [];
        },
        getParentId: (elementId)=>{
            return tree[elementId] ? tree[elementId].parent : null;
        }
    };
};
const FlowchartToExcalidrawSkeletonConverter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$GraphConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GraphConverter"]({
    converter: (graph, options)=>{
        const elements = [];
        const fontSize = options.fontSize;
        const { getGroupIds, getParentId } = computeGroupIds(graph);
        // SubGraphs
        graph.subGraphs.reverse().forEach((subGraph)=>{
            const groupIds = getGroupIds(subGraph.id);
            const containerElement = {
                id: subGraph.id,
                type: "rectangle",
                groupIds,
                x: subGraph.x,
                y: subGraph.y,
                width: subGraph.width,
                height: subGraph.height,
                label: {
                    groupIds,
                    text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getText"])(subGraph),
                    fontSize,
                    verticalAlign: "top"
                }
            };
            elements.push(containerElement);
        });
        // Vertices
        Object.values(graph.vertices).forEach((vertex)=>{
            if (!vertex) {
                return;
            }
            const groupIds = getGroupIds(vertex.id);
            // Compute custom style
            const containerStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeExcalidrawVertexStyle"])(vertex.containerStyle);
            const labelStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeExcalidrawVertexLabelStyle"])(vertex.labelStyle);
            let containerElement = {
                id: vertex.id,
                type: "rectangle",
                groupIds,
                x: vertex.x,
                y: vertex.y,
                width: vertex.width,
                height: vertex.height,
                strokeWidth: 2,
                label: {
                    groupIds,
                    text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getText"])(vertex),
                    fontSize,
                    ...labelStyle
                },
                link: vertex.link || null,
                ...containerStyle
            };
            switch(vertex.type){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERTEX_TYPE"].STADIUM:
                    {
                        containerElement = {
                            ...containerElement,
                            roundness: {
                                type: 3
                            }
                        };
                        break;
                    }
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERTEX_TYPE"].ROUND:
                    {
                        containerElement = {
                            ...containerElement,
                            roundness: {
                                type: 3
                            }
                        };
                        break;
                    }
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERTEX_TYPE"].DOUBLECIRCLE:
                    {
                        const CIRCLE_MARGIN = 5;
                        // Create new groupId for double circle
                        groupIds.push(`doublecircle_${vertex.id}}`);
                        // Create inner circle element
                        const innerCircle = {
                            type: "ellipse",
                            groupIds,
                            x: vertex.x + CIRCLE_MARGIN,
                            y: vertex.y + CIRCLE_MARGIN,
                            width: vertex.width - CIRCLE_MARGIN * 2,
                            height: vertex.height - CIRCLE_MARGIN * 2,
                            strokeWidth: 2,
                            roundness: {
                                type: 3
                            },
                            label: {
                                groupIds,
                                text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getText"])(vertex),
                                fontSize
                            }
                        };
                        containerElement = {
                            ...containerElement,
                            groupIds,
                            type: "ellipse"
                        };
                        elements.push(innerCircle);
                        break;
                    }
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERTEX_TYPE"].CIRCLE:
                    {
                        containerElement.type = "ellipse";
                        break;
                    }
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$interfaces$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERTEX_TYPE"].DIAMOND:
                    {
                        containerElement.type = "diamond";
                        break;
                    }
            }
            elements.push(containerElement);
        });
        // Edges
        graph.edges.forEach((edge)=>{
            let groupIds = [];
            const startParentId = getParentId(edge.start);
            const endParentId = getParentId(edge.end);
            if (startParentId && startParentId === endParentId) {
                groupIds = getGroupIds(startParentId);
            }
            // Get arrow position data
            const { startX, startY, reflectionPoints } = edge;
            // Calculate Excalidraw arrow's points
            const points = reflectionPoints.map((point)=>[
                    point.x - reflectionPoints[0].x,
                    point.y - reflectionPoints[0].y
                ]);
            // Get supported arrow type
            const arrowType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeExcalidrawArrowType"])(edge.type);
            const arrowId = `${edge.start}_${edge.end}`;
            const containerElement = {
                id: arrowId,
                type: "arrow",
                groupIds,
                x: startX,
                y: startY,
                // 4 and 2 are the Excalidraw's stroke width of thick and thin respectively
                // TODO: use constant exported from Excalidraw package
                strokeWidth: edge.stroke === "thick" ? 4 : 2,
                strokeStyle: edge.stroke === "dotted" ? "dashed" : undefined,
                points,
                ...edge.text ? {
                    label: {
                        text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getText"])(edge),
                        fontSize,
                        groupIds
                    }
                } : {},
                roundness: {
                    type: 2
                },
                ...arrowType
            };
            // Bind start and end vertex to arrow
            const startVertex = elements.find((e)=>e.id === edge.start);
            const endVertex = elements.find((e)=>e.id === edge.end);
            if (!startVertex || !endVertex) {
                return;
            }
            containerElement.start = {
                id: startVertex.id || ""
            };
            containerElement.end = {
                id: endVertex.id || ""
            };
            elements.push(containerElement);
        });
        return {
            elements
        };
    }
});
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/graphImage.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GraphImageConverter": (()=>GraphImageConverter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$GraphConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/GraphConverter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>");
;
;
const GraphImageConverter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$GraphConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GraphConverter"]({
    converter: (graph)=>{
        const imageId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])();
        const { width, height } = graph;
        const imageElement = {
            type: "image",
            x: 0,
            y: 0,
            width,
            height,
            status: "saved",
            fileId: imageId
        };
        const files = {
            [imageId]: {
                id: imageId,
                mimeType: graph.mimeType,
                dataURL: graph.dataURL
            }
        };
        return {
            files,
            elements: [
                imageElement
            ]
        };
    }
});
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/transformToExcalidrawSkeleton.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normalizeText": (()=>normalizeText),
    "transformToExcalidrawArrowSkeleton": (()=>transformToExcalidrawArrowSkeleton),
    "transformToExcalidrawContainerSkeleton": (()=>transformToExcalidrawContainerSkeleton),
    "transformToExcalidrawLineSkeleton": (()=>transformToExcalidrawLineSkeleton),
    "transformToExcalidrawTextSkeleton": (()=>transformToExcalidrawTextSkeleton)
});
const normalizeText = (text)=>{
    return text.replace(/\\n/g, "\n");
};
const transformToExcalidrawLineSkeleton = (line)=>{
    const lineElement = {
        type: "line",
        x: line.startX,
        y: line.startY,
        points: [
            [
                0,
                0
            ],
            [
                line.endX - line.startX,
                line.endY - line.startY
            ]
        ],
        width: line.endX - line.startX,
        height: line.endY - line.startY,
        strokeStyle: line.strokeStyle || "solid",
        strokeColor: line.strokeColor || "#000",
        strokeWidth: line.strokeWidth || 1
    };
    if (line.groupId) {
        Object.assign(lineElement, {
            groupIds: [
                line.groupId
            ]
        });
    }
    if (line.id) {
        Object.assign(lineElement, {
            id: line.id
        });
    }
    return lineElement;
};
const transformToExcalidrawTextSkeleton = (element)=>{
    const textElement = {
        type: "text",
        x: element.x,
        y: element.y,
        width: element.width,
        height: element.height,
        text: normalizeText(element.text) || "",
        fontSize: element.fontSize,
        verticalAlign: "middle"
    };
    if (element.groupId) {
        Object.assign(textElement, {
            groupIds: [
                element.groupId
            ]
        });
    }
    if (element.id) {
        Object.assign(textElement, {
            id: element.id
        });
    }
    return textElement;
};
const transformToExcalidrawContainerSkeleton = (element)=>{
    let extraProps = {};
    if (element.type === "rectangle" && element.subtype === "activation") {
        extraProps = {
            backgroundColor: "#e9ecef",
            fillStyle: "solid"
        };
    }
    const container = {
        id: element.id,
        type: element.type,
        x: element.x,
        y: element.y,
        width: element.width,
        height: element.height,
        label: {
            text: normalizeText(element?.label?.text || ""),
            fontSize: element?.label?.fontSize,
            verticalAlign: element.label?.verticalAlign || "middle",
            strokeColor: element.label?.color || "#000",
            groupIds: element.groupId ? [
                element.groupId
            ] : []
        },
        strokeStyle: element?.strokeStyle,
        strokeWidth: element?.strokeWidth,
        strokeColor: element?.strokeColor,
        backgroundColor: element?.bgColor,
        fillStyle: "solid",
        ...extraProps
    };
    if (element.groupId) {
        Object.assign(container, {
            groupIds: [
                element.groupId
            ]
        });
    }
    return container;
};
const transformToExcalidrawArrowSkeleton = (arrow)=>{
    const arrowElement = {
        type: "arrow",
        x: arrow.startX,
        y: arrow.startY,
        points: arrow.points || [
            [
                0,
                0
            ],
            [
                arrow.endX - arrow.startX,
                arrow.endY - arrow.startY
            ]
        ],
        width: arrow.endX - arrow.startX,
        height: arrow.endY - arrow.startY,
        strokeStyle: arrow?.strokeStyle || "solid",
        endArrowhead: arrow?.endArrowhead || null,
        startArrowhead: arrow?.startArrowhead || null,
        label: {
            text: normalizeText(arrow?.label?.text || ""),
            fontSize: 16
        },
        roundness: {
            type: 2
        },
        start: arrow.start,
        end: arrow.end
    };
    if (arrow.groupId) {
        Object.assign(arrowElement, {
            groupIds: [
                arrow.groupId
            ]
        });
    }
    return arrowElement;
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/sequence.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "SequenceToExcalidrawSkeletonConvertor": (()=>SequenceToExcalidrawSkeletonConvertor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$GraphConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/GraphConverter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/transformToExcalidrawSkeleton.js [app-client] (ecmascript)");
;
;
;
const SequenceToExcalidrawSkeletonConvertor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$GraphConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GraphConverter"]({
    converter: (chart)=>{
        const elements = [];
        const activations = [];
        Object.values(chart.nodes).forEach((node)=>{
            if (!node || !node.length) {
                return;
            }
            node.forEach((element)=>{
                let excalidrawElement;
                switch(element.type){
                    case "line":
                        excalidrawElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawLineSkeleton"])(element);
                        break;
                    case "rectangle":
                    case "ellipse":
                        excalidrawElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawContainerSkeleton"])(element);
                        break;
                    case "text":
                        excalidrawElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawTextSkeleton"])(element);
                        break;
                    default:
                        throw `unknown type ${element.type}`;
                        break;
                }
                if (element.type === "rectangle" && element?.subtype === "activation") {
                    activations.push(excalidrawElement);
                } else {
                    elements.push(excalidrawElement);
                }
            });
        });
        Object.values(chart.lines).forEach((line)=>{
            if (!line) {
                return;
            }
            elements.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawLineSkeleton"])(line));
        });
        Object.values(chart.arrows).forEach((arrow)=>{
            if (!arrow) {
                return;
            }
            elements.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawArrowSkeleton"])(arrow));
            if (arrow.sequenceNumber) {
                elements.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawContainerSkeleton"])(arrow.sequenceNumber));
            }
        });
        elements.push(...activations);
        // loops
        if (chart.loops) {
            const { lines, texts, nodes } = chart.loops;
            lines.forEach((line)=>{
                elements.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawLineSkeleton"])(line));
            });
            texts.forEach((text)=>{
                elements.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawTextSkeleton"])(text));
            });
            nodes.forEach((node)=>{
                elements.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawContainerSkeleton"])(node));
            });
        }
        if (chart.groups) {
            chart.groups.forEach((group)=>{
                const { actorKeys, name } = group;
                let minX = Infinity;
                let minY = Infinity;
                let maxX = 0;
                let maxY = 0;
                if (!actorKeys.length) {
                    return;
                }
                const actors = elements.filter((ele)=>{
                    if (ele.id) {
                        const hyphenIndex = ele.id.indexOf("-");
                        const id = ele.id.substring(0, hyphenIndex);
                        return actorKeys.includes(id);
                    }
                });
                actors.forEach((actor)=>{
                    if (actor.x === undefined || actor.y === undefined || actor.width === undefined || actor.height === undefined) {
                        throw new Error(`Actor attributes missing ${actor}`);
                    }
                    minX = Math.min(minX, actor.x);
                    minY = Math.min(minY, actor.y);
                    maxX = Math.max(maxX, actor.x + actor.width);
                    maxY = Math.max(maxY, actor.y + actor.height);
                });
                // Draw the outer rectangle enclosing the group elements
                const PADDING = 10;
                const groupRectX = minX - PADDING;
                const groupRectY = minY - PADDING;
                const groupRectWidth = maxX - minX + PADDING * 2;
                const groupRectHeight = maxY - minY + PADDING * 2;
                const groupRectId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])();
                const groupRect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawContainerSkeleton"])({
                    type: "rectangle",
                    x: groupRectX,
                    y: groupRectY,
                    width: groupRectWidth,
                    height: groupRectHeight,
                    bgColor: group.fill,
                    id: groupRectId
                });
                elements.unshift(groupRect);
                const frameId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])();
                const frameChildren = [
                    groupRectId
                ];
                elements.forEach((ele)=>{
                    if (ele.type === "frame") {
                        return;
                    }
                    if (ele.x === undefined || ele.y === undefined || ele.width === undefined || ele.height === undefined) {
                        throw new Error(`Element attributes missing ${ele}`);
                    }
                    if (ele.x >= minX && ele.x + ele.width <= maxX && ele.y >= minY && ele.y + ele.height <= maxY) {
                        const elementId = ele.id || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])();
                        if (!ele.id) {
                            Object.assign(ele, {
                                id: elementId
                            });
                        }
                        frameChildren.push(elementId);
                    }
                });
                const frame = {
                    type: "frame",
                    id: frameId,
                    name,
                    children: frameChildren
                };
                elements.push(frame);
            });
        }
        return {
            elements
        };
    }
});
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/class.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "classToExcalidrawSkeletonConvertor": (()=>classToExcalidrawSkeletonConvertor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/transformToExcalidrawSkeleton.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$GraphConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/GraphConverter.js [app-client] (ecmascript)");
;
;
;
const classToExcalidrawSkeletonConvertor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$GraphConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GraphConverter"]({
    converter: (chart)=>{
        const elements = [];
        Object.values(chart.nodes).forEach((node)=>{
            if (!node || !node.length) {
                return;
            }
            node.forEach((element)=>{
                let excalidrawElement;
                switch(element.type){
                    case "line":
                        excalidrawElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawLineSkeleton"])(element);
                        break;
                    case "rectangle":
                    case "ellipse":
                        excalidrawElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawContainerSkeleton"])(element);
                        break;
                    case "text":
                        excalidrawElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawTextSkeleton"])(element);
                        break;
                    default:
                        throw `unknown type ${element.type}`;
                        break;
                }
                elements.push(excalidrawElement);
            });
        });
        Object.values(chart.lines).forEach((line)=>{
            if (!line) {
                return;
            }
            elements.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawLineSkeleton"])(line));
        });
        Object.values(chart.arrows).forEach((arrow)=>{
            if (!arrow) {
                return;
            }
            const excalidrawElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawArrowSkeleton"])(arrow);
            elements.push(excalidrawElement);
        });
        Object.values(chart.text).forEach((ele)=>{
            const excalidrawElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$transformToExcalidrawSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToExcalidrawTextSkeleton"])(ele);
            elements.push(excalidrawElement);
        });
        Object.values(chart.namespaces).forEach((namespace)=>{
            const classIds = Object.keys(namespace.classes);
            const children = [
                ...classIds
            ];
            const chartElements = [
                ...chart.lines,
                ...chart.arrows,
                ...chart.text
            ];
            classIds.forEach((classId)=>{
                const childIds = chartElements.filter((ele)=>ele.metadata && ele.metadata.classId === classId).map((ele)=>ele.id);
                if (childIds.length) {
                    children.push(...childIds);
                }
            });
            const frame = {
                type: "frame",
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])(),
                name: namespace.id,
                children
            };
            elements.push(frame);
        });
        return {
            elements
        };
    }
});
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/graphToExcalidraw.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "graphToExcalidraw": (()=>graphToExcalidraw)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$types$2f$flowchart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/flowchart.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$types$2f$graphImage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/graphImage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$types$2f$sequence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/sequence.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$types$2f$class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/class.js [app-client] (ecmascript)");
;
;
;
;
const graphToExcalidraw = (graph, options = {})=>{
    switch(graph.type){
        case "graphImage":
            {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$types$2f$graphImage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GraphImageConverter"].convert(graph, options);
            }
        case "flowchart":
            {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$types$2f$flowchart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FlowchartToExcalidrawSkeletonConverter"].convert(graph, options);
            }
        case "sequence":
            {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$types$2f$sequence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SequenceToExcalidrawSkeletonConvertor"].convert(graph, options);
            }
        case "class":
            {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$converter$2f$types$2f$class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["classToExcalidrawSkeletonConvertor"].convert(graph, options);
            }
        default:
            {
                throw new Error(`graphToExcalidraw: unknown graph type "${graph.type}, only flowcharts are supported!"`);
            }
    }
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
// Convert mermaid entity codes to text e.g. "#9829;" to ""
__turbopack_context__.s({
    "computeEdgePositions": (()=>computeEdgePositions),
    "decodeEntities": (()=>decodeEntities),
    "encodeEntities": (()=>encodeEntities),
    "entityCodesToText": (()=>entityCodesToText),
    "getTransformAttr": (()=>getTransformAttr)
});
const entityCodesToText = (input)=>{
    input = decodeEntities(input);
    // Append & before the pattern #(\d+); or #([a-z]+); to convert to decimal code
    // so it can be rendered as html character
    // eg #9829; => &#9829;
    const inputWithDecimalCode = input.replace(/#(\d+);/g, "&#$1;").replace(/#([a-z]+);/g, "&$1;");
    // Render the decimal code as html character, eg &#9829; => 
    const element = document.createElement("textarea");
    element.innerHTML = inputWithDecimalCode;
    return element.value;
};
const getTransformAttr = (el)=>{
    const transformAttr = el.getAttribute("transform");
    const translateMatch = transformAttr?.match(/translate\(([ \d.-]+),\s*([\d.-]+)\)/);
    let transformX = 0;
    let transformY = 0;
    if (translateMatch) {
        transformX = Number(translateMatch[1]);
        transformY = Number(translateMatch[2]);
    }
    return {
        transformX,
        transformY
    };
};
const encodeEntities = (text)=>{
    let txt = text;
    txt = txt.replace(/style.*:\S*#.*;/g, (s)=>{
        return s.substring(0, s.length - 1);
    });
    txt = txt.replace(/classDef.*:\S*#.*;/g, (s)=>{
        return s.substring(0, s.length - 1);
    });
    txt = txt.replace(/#\w+;/g, (s)=>{
        const innerTxt = s.substring(1, s.length - 1);
        const isInt = /^\+?\d+$/.test(innerTxt);
        if (isInt) {
            return `${innerTxt}`;
        }
        return `${innerTxt}`;
    });
    return txt;
};
const decodeEntities = function(text) {
    return text.replace(//g, "#").replace(//g, "&").replace(//g, ";");
};
const computeEdgePositions = (pathElement, offset = {
    x: 0,
    y: 0
})=>{
    // Check if the element is a path else throw an error
    if (pathElement.tagName.toLowerCase() !== "path") {
        throw new Error(`Invalid input: Expected an HTMLElement of tag "path", got ${pathElement.tagName}`);
    }
    // Get the d attribute from the path element else throw an error
    const dAttr = pathElement.getAttribute("d");
    if (!dAttr) {
        throw new Error('Path element does not contain a "d" attribute');
    }
    // Split the d attribute based on M (Move To) and L (Line To) commands
    // eg "M29.383,38.5L29.383,63.5L29.383,83.2" => ["M29.383,38.5", "L29.383,63.5", "L29.383,83.2"]
    const commands = dAttr.split(/(?=[LM])/);
    // Get the start position from the first commands element => [29.383,38.5]
    const startPosition = commands[0].substring(1).split(",").map((coord)=>parseFloat(coord));
    // Get the last position from the last commands element => [29.383,83.2]
    const endPosition = commands[commands.length - 1].substring(1).split(",").map((coord)=>parseFloat(coord));
    // compute the reflection points -> [ {x: 29.383, y: 38.5}, {x: 29.383, y: 83.2} ]
    // These includes the start and end points and also points which are not the same as the previous points
    const reflectionPoints = commands.map((command)=>{
        const coords = command.substring(1).split(",").map((coord)=>parseFloat(coord));
        return {
            x: coords[0],
            y: coords[1]
        };
    }).filter((point, index, array)=>{
        // Always include the last point
        if (index === 0 || index === array.length - 1) {
            return true;
        }
        // Exclude the points which are the same as the previous point
        if (point.x === array[index - 1].x && point.y === array[index - 1].y) {
            return false;
        }
        // The below check is exclusively for second last point
        if (index === array.length - 2 && (array[index - 1].x === point.x || array[index - 1].y === point.y)) {
            const lastPoint = array[array.length - 1];
            // Get the distance between the last point and second last point using Euclidean distance formula
            const distance = Math.hypot(lastPoint.x - point.x, lastPoint.y - point.y);
            // Include the second last point if the distance between the
            // last point and second last point is > 20.
            // This is to ensure we have a distance for render the edge.
            // 20 seems to be a good enough distance to render the edge
            return distance > 20;
        }
        // Always include if the current point is not the same as the previous point
        return point.x !== array[index - 1].x || point.y !== array[index - 1].y;
    }).map((p)=>{
        // Offset the point by the provided offset
        return {
            x: p.x + offset.x,
            y: p.y + offset.y
        };
    });
    // Return the edge positions
    return {
        startX: startPosition[0] + offset.x,
        startY: startPosition[1] + offset.y,
        endX: endPosition[0] + offset.x,
        endY: endPosition[1] + offset.y,
        reflectionPoints
    };
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/flowchart.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseMermaidFlowChartDiagram": (()=>parseMermaidFlowChartDiagram)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/utils.js [app-client] (ecmascript)");
;
const parseSubGraph = (data, containerEl)=>{
    // Extract only node id for better reference
    // e.g. full element id = "flowchart-c1-205" will map to "c1"
    const nodeIds = data.nodes.map((n)=>{
        if (n.startsWith("flowchart-")) {
            return n.split("-")[1];
        }
        return n;
    });
    // Get position
    const el = containerEl.querySelector(`[id='${data.id}']`);
    if (!el) {
        throw new Error("SubGraph element not found");
    }
    const position = computeElementPosition(el, containerEl);
    // Get dimension
    const boundingBox = el.getBBox();
    const dimension = {
        width: boundingBox.width,
        height: boundingBox.height
    };
    // Remove irrelevant properties
    data.classes = undefined;
    data.dir = undefined;
    return {
        ...data,
        nodeIds,
        ...position,
        ...dimension,
        text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entityCodesToText"])(data.title)
    };
};
const parseVertex = (data, containerEl)=>{
    // Find Vertex element
    const el = containerEl.querySelector(`[id*="flowchart-${data.id}-"]`);
    if (!el) {
        return undefined;
    }
    // Check if Vertex attached with link
    let link;
    if (el.parentElement?.tagName.toLowerCase() === "a") {
        link = el.parentElement.getAttribute("xlink:href");
    }
    // Get position
    const position = computeElementPosition(link ? el.parentElement : el, containerEl);
    // Get dimension
    const boundingBox = el.getBBox();
    const dimension = {
        width: boundingBox.width,
        height: boundingBox.height
    };
    // Extract style
    const labelContainerStyleText = el.querySelector(".label-container")?.getAttribute("style");
    const labelStyleText = el.querySelector(".label")?.getAttribute("style");
    const containerStyle = {};
    labelContainerStyleText?.split(";").forEach((property)=>{
        if (!property) {
            return;
        }
        const key = property.split(":")[0].trim();
        const value = property.split(":")[1].trim();
        containerStyle[key] = value;
    });
    const labelStyle = {};
    labelStyleText?.split(";").forEach((property)=>{
        if (!property) {
            return;
        }
        const key = property.split(":")[0].trim();
        const value = property.split(":")[1].trim();
        labelStyle[key] = value;
    });
    return {
        id: data.id,
        labelType: data.labelType,
        text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entityCodesToText"])(data.text),
        type: data.type,
        link: link || undefined,
        ...position,
        ...dimension,
        containerStyle,
        labelStyle
    };
};
const parseEdge = (data, edgeIndex, containerEl)=>{
    // Find edge element
    const edge = containerEl.querySelector(`[id*="L-${data.start}-${data.end}-${edgeIndex}"]`);
    if (!edge) {
        throw new Error("Edge element not found");
    }
    // Compute edge position data
    const position = computeElementPosition(edge, containerEl);
    const edgePositionData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeEdgePositions"])(edge, position);
    // Remove irrelevant properties
    data.length = undefined;
    return {
        ...data,
        ...edgePositionData,
        text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entityCodesToText"])(data.text)
    };
};
// Compute element position
const computeElementPosition = (el, containerEl)=>{
    if (!el) {
        throw new Error("Element not found");
    }
    let root = el.parentElement?.parentElement;
    const childElement = el.childNodes[0];
    let childPosition = {
        x: 0,
        y: 0
    };
    if (childElement) {
        const { transformX, transformY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTransformAttr"])(childElement);
        const boundingBox = childElement.getBBox();
        childPosition = {
            x: Number(childElement.getAttribute("x")) || transformX + boundingBox.x || 0,
            y: Number(childElement.getAttribute("y")) || transformY + boundingBox.y || 0
        };
    }
    const { transformX, transformY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTransformAttr"])(el);
    const position = {
        x: transformX + childPosition.x,
        y: transformY + childPosition.y
    };
    while(root && root.id !== containerEl.id){
        if (root.classList.value === "root" && root.hasAttribute("transform")) {
            const { transformX, transformY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTransformAttr"])(root);
            position.x += transformX;
            position.y += transformY;
        }
        root = root.parentElement;
    }
    return position;
};
const parseMermaidFlowChartDiagram = (diagram, containerEl)=>{
    // This does some cleanup and initialization making sure
    // diagram is parsed correctly. Useful when multiple diagrams are
    // parsed together one after another, eg in playground
    // https://github.com/mermaid-js/mermaid/blob/e561cbd3be2a93b8bedfa4839484966faad92ccf/packages/mermaid/src/Diagram.ts#L43
    diagram.parse();
    // Get mermaid parsed data from parser shared variable `yy`
    //@ts-ignore
    const mermaidParser = diagram.parser.yy;
    const vertices = mermaidParser.getVertices();
    Object.keys(vertices).forEach((id)=>{
        vertices[id] = parseVertex(vertices[id], containerEl);
    });
    // Track the count of edges based on the edge id
    const edgeCountMap = new Map();
    const edges = mermaidParser.getEdges().filter((edge)=>{
        // Sometimes mermaid parser returns edges which are not present in the DOM hence this is a safety check to only consider edges present in the DOM, issue - https://github.com/mermaid-js/mermaid/issues/5516
        return containerEl.querySelector(`[id*="L-${edge.start}-${edge.end}"]`);
    }).map((data)=>{
        const edgeId = `${data.start}-${data.end}`;
        const count = edgeCountMap.get(edgeId) || 0;
        edgeCountMap.set(edgeId, count + 1);
        return parseEdge(data, count, containerEl);
    });
    const subGraphs = mermaidParser.getSubGraphs().map((data)=>parseSubGraph(data, containerEl));
    return {
        type: "flowchart",
        subGraphs,
        vertices,
        edges
    };
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/elementSkeleton.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createArrowSkeletion": (()=>createArrowSkeletion),
    "createArrowSkeletonFromSVG": (()=>createArrowSkeletonFromSVG),
    "createContainerSkeletonFromSVG": (()=>createContainerSkeletonFromSVG),
    "createLineSkeletonFromSVG": (()=>createLineSkeletonFromSVG),
    "createTextSkeleton": (()=>createTextSkeleton),
    "createTextSkeletonFromSVG": (()=>createTextSkeletonFromSVG)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/constants.js [app-client] (ecmascript)");
;
;
const createArrowSkeletonFromSVG = (arrowNode, opts)=>{
    const arrow = {};
    if (opts?.label) {
        arrow.label = {
            text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entityCodesToText"])(opts.label),
            fontSize: 16
        };
    }
    const tagName = arrowNode.tagName;
    if (tagName === "line") {
        arrow.startX = Number(arrowNode.getAttribute("x1"));
        arrow.startY = Number(arrowNode.getAttribute("y1"));
        arrow.endX = Number(arrowNode.getAttribute("x2"));
        arrow.endY = Number(arrowNode.getAttribute("y2"));
    } else if (tagName === "path") {
        const dAttr = arrowNode.getAttribute("d");
        if (!dAttr) {
            throw new Error('Path element does not contain a "d" attribute');
        }
        // Split the d attribute based on M (Move To)  and C (Curve) commands
        const commands = dAttr.split(/(?=[LC])/);
        const startPosition = commands[0].substring(1).split(",").map((coord)=>parseFloat(coord));
        const points = [];
        commands.forEach((command)=>{
            const currPoints = command.substring(1).trim().split(" ").map((pos)=>{
                const [x, y] = pos.split(",");
                return [
                    parseFloat(x) - startPosition[0],
                    parseFloat(y) - startPosition[1]
                ];
            });
            points.push(...currPoints);
        });
        const endPosition = points[points.length - 1];
        arrow.startX = startPosition[0];
        arrow.startY = startPosition[1];
        arrow.endX = endPosition[0];
        arrow.endY = endPosition[1];
        arrow.points = points;
    }
    if (opts?.label) {
        // In mermaid the text is positioned above arrow but in Excalidraw
        // its postioned on the arrow hence the elements below it might look cluttered so shifting the arrow by an offset of 10px
        const offset = 10;
        arrow.startY = arrow.startY - offset;
        arrow.endY = arrow.endY - offset;
    }
    arrow.strokeColor = arrowNode.getAttribute("stroke");
    arrow.strokeWidth = Number(arrowNode.getAttribute("stroke-width"));
    arrow.type = "arrow";
    arrow.strokeStyle = opts?.strokeStyle || "solid";
    arrow.startArrowhead = opts?.startArrowhead || null;
    arrow.endArrowhead = opts?.endArrowhead || null;
    return arrow;
};
const createArrowSkeletion = (startX, startY, endX, endY, opts)=>{
    const arrow = {};
    arrow.type = "arrow";
    arrow.startX = startX;
    arrow.startY = startY;
    arrow.endX = endX;
    arrow.endY = endY;
    Object.assign(arrow, {
        ...opts
    });
    return arrow;
};
const createTextSkeleton = (x, y, text, opts)=>{
    const textElement = {
        type: "text",
        x,
        y,
        text,
        width: opts?.width || 20,
        height: opts?.height || 20,
        fontSize: opts?.fontSize || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONT_SIZE"],
        id: opts?.id,
        groupId: opts?.groupId,
        metadata: opts?.metadata
    };
    return textElement;
};
const createTextSkeletonFromSVG = (textNode, text, opts)=>{
    const node = {};
    const x = Number(textNode.getAttribute("x"));
    const y = Number(textNode.getAttribute("y"));
    node.type = "text";
    node.text = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entityCodesToText"])(text);
    if (opts?.id) {
        node.id = opts.id;
    }
    if (opts?.groupId) {
        node.groupId = opts.groupId;
    }
    const boundingBox = textNode.getBBox();
    node.width = boundingBox.width;
    node.height = boundingBox.height;
    node.x = x - boundingBox.width / 2;
    node.y = y;
    const fontSize = parseInt(getComputedStyle(textNode).fontSize);
    node.fontSize = fontSize;
    return node;
};
const createContainerSkeletonFromSVG = (node, type, opts = {})=>{
    const container = {};
    container.type = type;
    const { label, subtype, id, groupId } = opts;
    container.id = id;
    if (groupId) {
        container.groupId = groupId;
    }
    if (label) {
        container.label = {
            text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entityCodesToText"])(label.text),
            fontSize: 16,
            verticalAlign: label?.verticalAlign
        };
    }
    const boundingBox = node.getBBox();
    container.x = boundingBox.x;
    container.y = boundingBox.y;
    container.width = boundingBox.width;
    container.height = boundingBox.height;
    container.subtype = subtype;
    switch(subtype){
        case "highlight":
            const bgColor = node.getAttribute("fill");
            if (bgColor) {
                container.bgColor = bgColor;
            }
            break;
        case "note":
            container.strokeStyle = "dashed";
            break;
    }
    return container;
};
const createLineSkeletonFromSVG = (lineNode, startX, startY, endX, endY, opts)=>{
    const line = {};
    line.startX = startX;
    line.startY = startY;
    line.endX = endX;
    if (opts?.groupId) {
        line.groupId = opts.groupId;
    }
    if (opts?.id) {
        line.id = opts.id;
    }
    // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent
    line.endY = endY;
    line.strokeColor = lineNode.getAttribute("stroke");
    line.strokeWidth = Number(lineNode.getAttribute("stroke-width"));
    line.type = "line";
    return line;
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/sequence.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseMermaidSequenceDiagram": (()=>parseMermaidSequenceDiagram)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/elementSkeleton.js [app-client] (ecmascript)");
;
;
;
// Currently mermaid supported these 6 arrow types, the names are taken from mermaidParser.LINETYPE
const SEQUENCE_ARROW_TYPES = {
    0: "SOLID",
    1: "DOTTED",
    3: "SOLID_CROSS",
    4: "DOTTED_CROSS",
    5: "SOLID_OPEN",
    6: "DOTTED_OPEN",
    24: "SOLID_POINT",
    25: "DOTTED_POINT"
};
const MESSAGE_TYPE = {
    SOLID: 0,
    DOTTED: 1,
    NOTE: 2,
    SOLID_CROSS: 3,
    DOTTED_CROSS: 4,
    SOLID_OPEN: 5,
    DOTTED_OPEN: 6,
    LOOP_START: 10,
    LOOP_END: 11,
    ALT_START: 12,
    ALT_ELSE: 13,
    ALT_END: 14,
    OPT_START: 15,
    OPT_END: 16,
    ACTIVE_START: 17,
    ACTIVE_END: 18,
    PAR_START: 19,
    PAR_AND: 20,
    PAR_END: 21,
    RECT_START: 22,
    RECT_END: 23,
    SOLID_POINT: 24,
    DOTTED_POINT: 25,
    AUTONUMBER: 26,
    CRITICAL_START: 27,
    CRITICAL_OPTION: 28,
    CRITICAL_END: 29,
    BREAK_START: 30,
    BREAK_END: 31,
    PAR_OVER_START: 32
};
const getStrokeStyle = (type)=>{
    let strokeStyle;
    switch(type){
        case MESSAGE_TYPE.SOLID:
        case MESSAGE_TYPE.SOLID_CROSS:
        case MESSAGE_TYPE.SOLID_OPEN:
        case MESSAGE_TYPE.SOLID_POINT:
            strokeStyle = "solid";
            break;
        case MESSAGE_TYPE.DOTTED:
        case MESSAGE_TYPE.DOTTED_CROSS:
        case MESSAGE_TYPE.DOTTED_OPEN:
        case MESSAGE_TYPE.DOTTED_POINT:
            strokeStyle = "dotted";
            break;
        default:
            strokeStyle = "solid";
            break;
    }
    return strokeStyle;
};
const attachSequenceNumberToArrow = (node, arrow)=>{
    const showSequenceNumber = !!node.nextElementSibling?.classList.contains("sequenceNumber");
    if (showSequenceNumber) {
        const text = node.nextElementSibling?.textContent;
        if (!text) {
            throw new Error("sequence number not present");
        }
        const height = 30;
        const yOffset = height / 2;
        const xOffset = 10;
        const sequenceNumber = {
            type: "rectangle",
            x: arrow.startX - xOffset,
            y: arrow.startY - yOffset,
            label: {
                text,
                fontSize: 14
            },
            bgColor: "#e9ecef",
            height,
            subtype: "sequence"
        };
        Object.assign(arrow, {
            sequenceNumber
        });
    }
};
const createActorSymbol = (rootNode, text, opts)=>{
    if (!rootNode) {
        throw "root node not found";
    }
    const groupId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])();
    const children = Array.from(rootNode.children);
    const nodeElements = [];
    children.forEach((child, index)=>{
        const id = `${opts?.id}-${index}`;
        let ele;
        switch(child.tagName){
            case "line":
                const startX = Number(child.getAttribute("x1"));
                const startY = Number(child.getAttribute("y1"));
                const endX = Number(child.getAttribute("x2"));
                const endY = Number(child.getAttribute("y2"));
                ele = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLineSkeletonFromSVG"])(child, startX, startY, endX, endY, {
                    groupId,
                    id
                });
                break;
            case "text":
                ele = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTextSkeletonFromSVG"])(child, text, {
                    groupId,
                    id
                });
                break;
            case "circle":
                ele = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(child, "ellipse", {
                    label: child.textContent ? {
                        text: child.textContent
                    } : undefined,
                    groupId,
                    id
                });
            default:
                ele = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(child, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SVG_TO_SHAPE_MAPPER"][child.tagName], {
                    label: child.textContent ? {
                        text: child.textContent
                    } : undefined,
                    groupId,
                    id
                });
        }
        nodeElements.push(ele);
    });
    return nodeElements;
};
const parseActor = (actors, containerEl)=>{
    const actorTopNodes = Array.from(containerEl.querySelectorAll(".actor-top"));
    const actorBottomNodes = Array.from(containerEl.querySelectorAll(".actor-bottom"));
    const nodes = [];
    const lines = [];
    Object.values(actors).forEach((actor, index)=>{
        const topRootNode = actorTopNodes.find((actorNode)=>actorNode.getAttribute("name") === actor.name);
        const bottomRootNode = actorBottomNodes.find((actorNode)=>actorNode.getAttribute("name") === actor.name);
        if (!topRootNode || !bottomRootNode) {
            throw "root not found";
        }
        const text = actor.description;
        if (actor.type === "participant") {
            // creating top actor node element
            const topNodeElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(topRootNode, "rectangle", {
                id: `${actor.name}-top`,
                label: {
                    text
                },
                subtype: "actor"
            });
            if (!topNodeElement) {
                throw "Top Node element not found!";
            }
            nodes.push([
                topNodeElement
            ]);
            // creating bottom actor node element
            const bottomNodeElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(bottomRootNode, "rectangle", {
                id: `${actor.name}-bottom`,
                label: {
                    text
                },
                subtype: "actor"
            });
            nodes.push([
                bottomNodeElement
            ]);
            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as sibling parent of top root node
            const lineNode = topRootNode?.parentElement?.previousElementSibling;
            if (lineNode?.tagName !== "line") {
                throw "Line not found";
            }
            const startX = Number(lineNode.getAttribute("x1"));
            if (!topNodeElement.height) {
                throw "Top node element height is null";
            }
            const startY = topNodeElement.y + topNodeElement.height;
            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent
            const endY = bottomNodeElement.y;
            const endX = Number(lineNode.getAttribute("x2"));
            const line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLineSkeletonFromSVG"])(lineNode, startX, startY, endX, endY);
            lines.push(line);
        } else if (actor.type === "actor") {
            const topNodeElement = createActorSymbol(topRootNode, text, {
                id: `${actor.name}-top`
            });
            nodes.push(topNodeElement);
            const bottomNodeElement = createActorSymbol(bottomRootNode, text, {
                id: `${actor.name}-bottom`
            });
            nodes.push(bottomNodeElement);
            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as sibling of the actor root element
            const lineNode = topRootNode.previousElementSibling;
            if (lineNode?.tagName !== "line") {
                throw "Line not found";
            }
            const startX = Number(lineNode.getAttribute("x1"));
            const startY = Number(lineNode.getAttribute("y1"));
            const endX = Number(lineNode.getAttribute("x2"));
            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent
            const bottomEllipseNode = bottomNodeElement.find((node)=>node.type === "ellipse");
            if (bottomEllipseNode) {
                const endY = bottomEllipseNode.y;
                const line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLineSkeletonFromSVG"])(lineNode, startX, startY, endX, endY);
                lines.push(line);
            }
        }
    });
    return {
        nodes,
        lines
    };
};
const computeArrows = (messages, containerEl)=>{
    const arrows = [];
    const arrowNodes = Array.from(containerEl.querySelectorAll('[class*="messageLine"]'));
    const supportedMessageTypes = Object.keys(SEQUENCE_ARROW_TYPES);
    const arrowMessages = messages.filter((message)=>supportedMessageTypes.includes(message.type.toString()));
    arrowNodes.forEach((arrowNode, index)=>{
        const message = arrowMessages[index];
        const messageType = SEQUENCE_ARROW_TYPES[message.type];
        const arrow = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createArrowSkeletonFromSVG"])(arrowNode, {
            label: message?.message,
            strokeStyle: getStrokeStyle(message.type),
            endArrowhead: messageType === "SOLID_OPEN" || messageType === "DOTTED_OPEN" ? null : "arrow"
        });
        attachSequenceNumberToArrow(arrowNode, arrow);
        arrows.push(arrow);
    });
    return arrows;
};
const computeNotes = (messages, containerEl)=>{
    const noteNodes = Array.from(containerEl.querySelectorAll(".note")).map((node)=>node.parentElement);
    const noteText = messages.filter((message)=>message.type === MESSAGE_TYPE.NOTE);
    const notes = [];
    noteNodes.forEach((node, index)=>{
        if (!node) {
            return;
        }
        const rect = node.firstChild;
        const text = noteText[index].message;
        const note = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(rect, "rectangle", {
            label: {
                text
            },
            subtype: "note"
        });
        notes.push(note);
    });
    return notes;
};
const parseActivations = (containerEl)=>{
    const activationNodes = Array.from(containerEl.querySelectorAll(`[class*=activation]`));
    const activations = [];
    activationNodes.forEach((node)=>{
        const rect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(node, "rectangle", {
            label: {
                text: ""
            },
            subtype: "activation"
        });
        activations.push(rect);
    });
    return activations;
};
const parseLoops = (messages, containerEl)=>{
    const lineNodes = Array.from(containerEl.querySelectorAll(".loopLine"));
    const lines = [];
    const texts = [];
    const nodes = [];
    lineNodes.forEach((node)=>{
        const startX = Number(node.getAttribute("x1"));
        const startY = Number(node.getAttribute("y1"));
        const endX = Number(node.getAttribute("x2"));
        const endY = Number(node.getAttribute("y2"));
        const line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLineSkeletonFromSVG"])(node, startX, startY, endX, endY);
        line.strokeStyle = "dotted";
        line.strokeColor = "#adb5bd";
        line.strokeWidth = 2;
        lines.push(line);
    });
    const loopTextNodes = Array.from(containerEl.querySelectorAll(".loopText"));
    const criticalMessages = messages.filter((message)=>message.type === MESSAGE_TYPE.CRITICAL_START).map((message)=>message.message);
    loopTextNodes.forEach((node)=>{
        const text = node.textContent || "";
        const textElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTextSkeletonFromSVG"])(node, text);
        // The text is rendered between [ ] in DOM hence getting the text excluding the [ ]
        const rawText = text.match(/\[(.*?)\]/)?.[1] || "";
        const isCritical = criticalMessages.includes(rawText);
        // For critical label the coordinates are not accurate in mermaid as there is
        // no padding left hence shifting the text next to critical label by 16px (font size)
        if (isCritical) {
            textElement.x += 16;
        }
        texts.push(textElement);
    });
    const labelBoxes = Array.from(containerEl?.querySelectorAll(".labelBox"));
    const labelTextNode = Array.from(containerEl?.querySelectorAll(".labelText"));
    labelBoxes.forEach((labelBox, index)=>{
        const text = labelTextNode[index]?.textContent || "";
        const container = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(labelBox, "rectangle", {
            label: {
                text
            }
        });
        container.strokeColor = "#adb5bd";
        container.bgColor = "#e9ecef";
        // So width is calculated based on label
        container.width = undefined;
        nodes.push(container);
    });
    return {
        lines,
        texts,
        nodes
    };
};
const computeHighlights = (containerEl)=>{
    const rects = Array.from(containerEl.querySelectorAll(".rect"))// Only drawing specifically for highlights as the same selector is for grouping as well. For grouping we
    // draw it ourselves
    .filter((node)=>node.parentElement?.tagName !== "g");
    const nodes = [];
    rects.forEach((rect)=>{
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(rect, "rectangle", {
            label: {
                text: ""
            },
            subtype: "highlight"
        });
        nodes.push(node);
    });
    return nodes;
};
const parseMermaidSequenceDiagram = (diagram, containerEl)=>{
    diagram.parse();
    // Get mermaid parsed data from parser shared variable `yy`
    //@ts-ignore
    const mermaidParser = diagram.parser.yy;
    const nodes = [];
    const groups = mermaidParser.getBoxes();
    const bgHightlights = computeHighlights(containerEl);
    const actorData = mermaidParser.getActors();
    const { nodes: actors, lines } = parseActor(actorData, containerEl);
    const messages = mermaidParser.getMessages();
    const arrows = computeArrows(messages, containerEl);
    const notes = computeNotes(messages, containerEl);
    const activations = parseActivations(containerEl);
    const loops = parseLoops(messages, containerEl);
    nodes.push(bgHightlights);
    nodes.push(...actors);
    nodes.push(notes);
    nodes.push(activations);
    return {
        type: "sequence",
        lines,
        arrows,
        nodes,
        loops,
        groups
    };
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/class.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseMermaidClassDiagram": (()=>parseMermaidClassDiagram)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/elementSkeleton.js [app-client] (ecmascript)");
;
;
;
// Taken from mermaidParser.relationType
const RELATION_TYPE = {
    AGGREGATION: 0,
    EXTENSION: 1,
    COMPOSITION: 2,
    DEPENDENCY: 3,
    LOLLIPOP: 4
};
// Taken from mermaidParser.lineType
const LINE_TYPE = {
    LINE: 0,
    DOTTED_LINE: 1
};
// This is the offset to update the arrow head postition for rendering in excalidraw as mermaid calculates the position until the start of arrowhead
const MERMAID_ARROW_HEAD_OFFSET = 16;
const getStrokeStyle = (type)=>{
    let lineType;
    switch(type){
        case LINE_TYPE.LINE:
            lineType = "solid";
            break;
        case LINE_TYPE.DOTTED_LINE:
            lineType = "dotted";
            break;
        default:
            lineType = "solid";
    }
    return lineType;
};
const getArrowhead = (type)=>{
    let arrowhead;
    switch(type){
        case RELATION_TYPE.AGGREGATION:
            arrowhead = "diamond_outline";
            break;
        case RELATION_TYPE.COMPOSITION:
            arrowhead = "diamond";
            break;
        case RELATION_TYPE.EXTENSION:
            arrowhead = "triangle_outline";
            break;
        case "none":
            arrowhead = null;
            break;
        case RELATION_TYPE.DEPENDENCY:
        default:
            arrowhead = "arrow";
            break;
    }
    return arrowhead;
};
const parseClasses = (classes, containerEl)=>{
    const nodes = [];
    const lines = [];
    const text = [];
    Object.values(classes).forEach((classNode)=>{
        const { domId, id: classId } = classNode;
        const groupId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])();
        const domNode = containerEl.querySelector(`[data-id=${classId}]`);
        if (!domNode) {
            throw Error(`DOM Node with id ${domId} not found`);
        }
        const { transformX, transformY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTransformAttr"])(domNode);
        const container = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(domNode.firstChild, "rectangle", {
            id: classId,
            groupId
        });
        container.x += transformX;
        container.y += transformY;
        container.metadata = {
            classId
        };
        nodes.push(container);
        const lineNodes = Array.from(domNode.querySelectorAll(".divider"));
        lineNodes.forEach((lineNode)=>{
            const startX = Number(lineNode.getAttribute("x1"));
            const startY = Number(lineNode.getAttribute("y1"));
            const endX = Number(lineNode.getAttribute("x2"));
            const endY = Number(lineNode.getAttribute("y2"));
            const line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLineSkeletonFromSVG"])(lineNode, startX, startY, endX, endY, {
                groupId,
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])()
            });
            line.startX += transformX;
            line.startY += transformY;
            line.endX += transformX;
            line.endY += transformY;
            line.metadata = {
                classId
            };
            lines.push(line);
        });
        const labelNodes = domNode.querySelector(".label")?.children;
        if (!labelNodes) {
            throw "label nodes not found";
        }
        Array.from(labelNodes).forEach((node)=>{
            const label = node.textContent;
            if (!label) {
                return;
            }
            const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])();
            const { transformX: textTransformX, transformY: textTransformY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTransformAttr"])(node);
            const boundingBox = node.getBBox();
            const offsetY = 10;
            const textElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTextSkeleton"])(transformX + textTransformX, transformY + textTransformY + offsetY, label, {
                width: boundingBox.width,
                height: boundingBox.height,
                id,
                groupId,
                metadata: {
                    classId
                }
            });
            text.push(textElement);
        });
    });
    return {
        nodes,
        lines,
        text
    };
};
// update arrow position by certain offset for triangle and diamond arrow head types
// as mermaid calculates the position until the start of arrowhead
// for reference - https://github.com/mermaid-js/mermaid/issues/5417
const adjustArrowPosition = (direction, arrow)=>{
    // The arrowhead shapes where we need to update the position by a 16px offset
    const arrowHeadShapes = [
        "triangle_outline",
        "diamond",
        "diamond_outline"
    ];
    const shouldUpdateStartArrowhead = arrow.startArrowhead && arrowHeadShapes.includes(arrow.startArrowhead);
    const shouldUpdateEndArrowhead = arrow.endArrowhead && arrowHeadShapes.includes(arrow.endArrowhead);
    if (!shouldUpdateEndArrowhead && !shouldUpdateStartArrowhead) {
        return arrow;
    }
    if (shouldUpdateStartArrowhead) {
        if (direction === "LR") {
            arrow.startX -= MERMAID_ARROW_HEAD_OFFSET;
        } else if (direction === "RL") {
            arrow.startX += MERMAID_ARROW_HEAD_OFFSET;
        } else if (direction === "TB") {
            arrow.startY -= MERMAID_ARROW_HEAD_OFFSET;
        } else if (direction === "BT") {
            arrow.startY += MERMAID_ARROW_HEAD_OFFSET;
        }
    }
    if (shouldUpdateEndArrowhead) {
        if (direction === "LR") {
            arrow.endX += MERMAID_ARROW_HEAD_OFFSET;
        } else if (direction === "RL") {
            arrow.endX -= MERMAID_ARROW_HEAD_OFFSET;
        } else if (direction === "TB") {
            arrow.endY += MERMAID_ARROW_HEAD_OFFSET;
        } else if (direction === "BT") {
            arrow.endY -= MERMAID_ARROW_HEAD_OFFSET;
        }
    }
    return arrow;
};
const parseRelations = (relations, classNodes, containerEl, direction)=>{
    const edges = containerEl.querySelector(".edgePaths")?.children;
    if (!edges) {
        throw new Error("No Edges found!");
    }
    const arrows = [];
    const text = [];
    relations.forEach((relationNode, index)=>{
        const { id1, id2, relation } = relationNode;
        const node1 = classNodes.find((node)=>node.id === id1);
        const node2 = classNodes.find((node)=>node.id === id2);
        const strokeStyle = getStrokeStyle(relation.lineType);
        const startArrowhead = getArrowhead(relation.type1);
        const endArrowhead = getArrowhead(relation.type2);
        const edgePositionData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeEdgePositions"])(edges[index]);
        const arrowSkeletion = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createArrowSkeletion"])(edgePositionData.startX, edgePositionData.startY, edgePositionData.endX, edgePositionData.endY, {
            strokeStyle,
            startArrowhead,
            endArrowhead,
            label: relationNode.title ? {
                text: relationNode.title
            } : undefined,
            start: {
                type: "rectangle",
                id: node1.id
            },
            end: {
                type: "rectangle",
                id: node2.id
            }
        });
        const arrow = adjustArrowPosition(direction, arrowSkeletion);
        arrows.push(arrow);
        // Add cardianlities and Multiplicities
        const { relationTitle1, relationTitle2 } = relationNode;
        const offsetX = 20;
        const offsetY = 15;
        const directionOffset = 15;
        let x;
        let y;
        if (relationTitle1 && relationTitle1 !== "none") {
            switch(direction){
                case "TB":
                    x = arrow.startX - offsetX;
                    if (arrow.endX < arrow.startX) {
                        x -= directionOffset;
                    }
                    y = arrow.startY + offsetY;
                    break;
                case "BT":
                    x = arrow.startX + offsetX;
                    if (arrow.endX > arrow.startX) {
                        x += directionOffset;
                    }
                    y = arrow.startY - offsetY;
                    break;
                case "LR":
                    x = arrow.startX + offsetX;
                    y = arrow.startY + offsetY;
                    if (arrow.endY > arrow.startY) {
                        y += directionOffset;
                    }
                    break;
                case "RL":
                    x = arrow.startX - offsetX;
                    y = arrow.startY - offsetY;
                    if (arrow.startY > arrow.endY) {
                        y -= directionOffset;
                    }
                    break;
                default:
                    x = arrow.startX - offsetX;
                    y = arrow.startY + offsetY;
            }
            const relationTitleElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTextSkeleton"])(x, y, relationTitle1, {
                fontSize: 16
            });
            text.push(relationTitleElement);
        }
        if (relationTitle2 && relationTitle2 !== "none") {
            switch(direction){
                case "TB":
                    x = arrow.endX + offsetX;
                    if (arrow.endX < arrow.startX) {
                        x += directionOffset;
                    }
                    y = arrow.endY - offsetY;
                    break;
                case "BT":
                    x = arrow.endX - offsetX;
                    if (arrow.endX > arrow.startX) {
                        x -= directionOffset;
                    }
                    y = arrow.endY + offsetY;
                    break;
                case "LR":
                    x = arrow.endX - offsetX;
                    y = arrow.endY - offsetY;
                    if (arrow.endY > arrow.startY) {
                        y -= directionOffset;
                    }
                    break;
                case "RL":
                    x = arrow.endX + offsetX;
                    y = arrow.endY + offsetY;
                    if (arrow.startY > arrow.endY) {
                        y += directionOffset;
                    }
                    break;
                default:
                    x = arrow.endX + offsetX;
                    y = arrow.endY - offsetY;
            }
            const relationTitleElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTextSkeleton"])(x, y, relationTitle2, {
                fontSize: 16
            });
            text.push(relationTitleElement);
        }
    });
    return {
        arrows,
        text
    };
};
const parseNotes = (notes, containerEl, classNodes)=>{
    const noteContainers = [];
    const connectors = [];
    notes.forEach((note)=>{
        const { id, text, class: classId } = note;
        const node = containerEl.querySelector(`#${id}`);
        if (!node) {
            throw new Error(`Node with id ${id} not found!`);
        }
        const { transformX, transformY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTransformAttr"])(node);
        const rect = node.firstChild;
        const container = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerSkeletonFromSVG"])(rect, "rectangle", {
            id,
            subtype: "note",
            label: {
                text
            }
        });
        Object.assign(container, {
            x: container.x + transformX,
            y: container.y + transformY
        });
        noteContainers.push(container);
        if (classId) {
            const classNode = classNodes.find((node)=>node.id === classId);
            if (!classNode) {
                throw new Error(`class node with id ${classId} not found!`);
            }
            const startX = container.x + (container.width || 0) / 2;
            const startY = container.y + (container.height || 0);
            const endX = startX;
            const endY = classNode.y;
            const connector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$elementSkeleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createArrowSkeletion"])(startX, startY, endX, endY, {
                strokeStyle: "dotted",
                startArrowhead: null,
                endArrowhead: null,
                start: {
                    id: container.id,
                    type: "rectangle"
                },
                end: {
                    id: classNode.id,
                    type: "rectangle"
                }
            });
            connectors.push(connector);
        }
    });
    return {
        notes: noteContainers,
        connectors
    };
};
const parseMermaidClassDiagram = (diagram, containerEl)=>{
    diagram.parse();
    //@ts-ignore
    const mermaidParser = diagram.parser.yy;
    const direction = mermaidParser.getDirection();
    const nodes = [];
    const lines = [];
    const text = [];
    const classNodes = [];
    const namespaces = mermaidParser.getNamespaces();
    const classes = mermaidParser.getClasses();
    if (Object.keys(classes).length) {
        const classData = parseClasses(classes, containerEl);
        nodes.push(classData.nodes);
        lines.push(...classData.lines);
        text.push(...classData.text);
        classNodes.push(...classData.nodes);
    }
    const relations = mermaidParser.getRelations();
    const { arrows, text: relationTitles } = parseRelations(relations, classNodes, containerEl, direction);
    const { notes, connectors } = parseNotes(mermaidParser.getNotes(), containerEl, classNodes);
    nodes.push(notes);
    arrows.push(...connectors);
    text.push(...relationTitles);
    return {
        type: "class",
        nodes,
        lines,
        arrows,
        text,
        namespaces
    };
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/parseMermaid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseMermaid": (()=>parseMermaid)
});
(()=>{
    const e = new Error("Cannot find module 'mermaid'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$parser$2f$flowchart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/flowchart.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$parser$2f$sequence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/sequence.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$parser$2f$class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/class.js [app-client] (ecmascript)");
;
;
;
;
;
;
// Fallback to Svg
const convertSvgToGraphImage = (svgContainer)=>{
    // Extract SVG width and height
    // TODO: make width and height change dynamically based on user's screen dimension
    const svgEl = svgContainer.querySelector("svg");
    if (!svgEl) {
        throw new Error("SVG element not found");
    }
    const rect = svgEl.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    // Set width and height explictly since in firefox it gets set to 0
    // if the width and height are not expilcitly set
    // eg in some cases like er Diagram, gnatt, width and height is set as 100%
    // which sets the dimensions as 0 in firefox and thus the diagram isn't rendered
    svgEl.setAttribute("width", `${width}`);
    svgEl.setAttribute("height", `${height}`);
    // Convert SVG to image
    const mimeType = "image/svg+xml";
    const decoded = unescape(encodeURIComponent(svgEl.outerHTML));
    const base64 = btoa(decoded);
    const dataURL = `data:image/svg+xml;base64,${base64}`;
    const graphImage = {
        type: "graphImage",
        mimeType,
        dataURL,
        width,
        height
    };
    return graphImage;
};
const parseMermaid = async (definition, config = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MERMAID_CONFIG"])=>{
    mermaid.initialize({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MERMAID_CONFIG"],
        ...config
    });
    // Parse the diagram
    const diagram = await mermaid.mermaidAPI.getDiagramFromText((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeEntities"])(definition));
    // Render the SVG diagram
    const { svg } = await mermaid.render("mermaid-to-excalidraw", definition);
    // Append Svg to DOM
    const svgContainer = document.createElement("div");
    svgContainer.setAttribute("style", `opacity: 0; position: relative; z-index: -1;`);
    svgContainer.innerHTML = svg;
    svgContainer.id = "mermaid-diagram";
    document.body.appendChild(svgContainer);
    let data;
    switch(diagram.type){
        case "flowchart-v2":
            {
                data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$parser$2f$flowchart$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseMermaidFlowChartDiagram"])(diagram, svgContainer);
                break;
            }
        case "sequence":
            {
                data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$parser$2f$sequence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseMermaidSequenceDiagram"])(diagram, svgContainer);
                break;
            }
        case "classDiagram":
            {
                data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$parser$2f$class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseMermaidClassDiagram"])(diagram, svgContainer);
                break;
            }
        // fallback to image if diagram type not-supported
        default:
            {
                data = convertSvgToGraphImage(svgContainer);
            }
    }
    svgContainer.remove();
    return data;
};
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseMermaidToExcalidraw": (()=>parseMermaidToExcalidraw)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$graphToExcalidraw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/graphToExcalidraw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$parseMermaid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@excalidraw/mermaid-to-excalidraw/dist/parseMermaid.js [app-client] (ecmascript)");
;
;
;
const parseMermaidToExcalidraw = async (definition, config)=>{
    const mermaidConfig = config || {};
    const fontSize = parseInt(mermaidConfig.themeVariables?.fontSize ?? "") || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_FONT_SIZE"];
    const parsedMermaidData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$parseMermaid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseMermaid"])(definition, {
        ...mermaidConfig,
        themeVariables: {
            ...mermaidConfig.themeVariables,
            // Multiplying by 1.25 to increase the font size by 25% and render correctly in Excalidraw
            fontSize: `${fontSize * 1.25}px`
        }
    });
    // Only font size supported for excalidraw elements
    const excalidrawElements = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$excalidraw$2f$mermaid$2d$to$2d$excalidraw$2f$dist$2f$graphToExcalidraw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["graphToExcalidraw"])(parsedMermaidData, {
        fontSize
    });
    return excalidrawElements;
};
;
}}),
"[project]/node_modules/@excalidraw/markdown-to-text/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.removeMarkdown = void 0;
/**
 * @function removeMarkdown
 *
 * @description
 * Parse the markdown and returns a string
 *
 * @param markdown - The markdown string to parse
 * @param options - The options for the function
 *
 * @returns The parsed plain text
 */ var removeMarkdown = function(markdown, options) {
    if (options === void 0) {
        options = {
            listUnicodeChar: ""
        };
    }
    options = options || {};
    options.listUnicodeChar = options.hasOwnProperty("listUnicodeChar") ? options.listUnicodeChar : false;
    options.stripListLeaders = options.hasOwnProperty("stripListLeaders") ? options.stripListLeaders : true;
    options.gfm = options.hasOwnProperty("gfm") ? options.gfm : true;
    options.useImgAltText = options.hasOwnProperty("useImgAltText") ? options.useImgAltText : true;
    options.preserveLinks = options.hasOwnProperty("preserveLinks") ? options.preserveLinks : false;
    var output = markdown || "";
    // Remove horizontal rules (stripListHeaders conflict with this rule, which is why it has been moved to the top)
    output = output.replace(/^(-\s*?|\*\s*?|_\s*?){3,}\s*$/gm, "");
    try {
        if (options.stripListLeaders) {
            if (options.listUnicodeChar) output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, options.listUnicodeChar + " $1");
            else output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, "$1");
        }
        if (options.gfm) {
            output = output// Header
            .replace(/\n={2,}/g, "\n")// Fenced codeblocks
            .replace(/~{3}.*\n/g, "")// Strikethrough
            .replace(/~~/g, "")// Fenced codeblocks
            .replace(/`{3}.*\n/g, "");
        }
        if (options.preserveLinks) {
            // Remove inline links while preserving the links
            output = output.replace(/\[(.*?)\][\[\(](.*?)[\]\)]/g, "$1 ($2)");
        }
        output = output// Remove HTML tags
        .replace(/<[^>]*>/g, "")// Remove setext-style headers
        .replace(/^[=\-]{2,}\s*$/g, "")// Remove footnotes?
        .replace(/\[\^.+?\](\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "")// Remove images
        .replace(/\!\[(.*?)\][\[\(].*?[\]\)]/g, options.useImgAltText ? "$1" : "")// Remove inline links
        .replace(/\[(.*?)\][\[\(].*?[\]\)]/g, "$1")// Remove blockquotes
        .replace(/^\s{0,3}>\s?/g, "").replace(/(^|\n)\s{0,3}>\s?/g, "\n\n")// Remove reference-style links?
        .replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "")// Remove atx-style headers
        .replace(/^(\n)?\s{0,}#{1,6}\s+| {0,}(\n)?\s{0,}#{0,} {0,}(\n)?\s{0,}$/gm, "$1$2$3")// Remove emphasis (repeat the line to remove double emphasis)
        .replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g, "$2").replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g, "$2")// Remove code blocks
        .replace(/(`{3,})(.*?)\1/gm, "$2")// Remove inline code
        .replace(/`(.+?)`/g, "$1")// Replace two or more newlines with exactly two? Not entirely sure this belongs here...
        .replace(/\n{2,}/g, "\n\n");
    } catch (e) {
        console.error(e);
        return markdown;
    }
    return output;
};
exports.removeMarkdown = removeMarkdown;
}}),
"[project]/node_modules/@excalidraw/mermaid-to-excalidraw/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "customAlphabet": (()=>customAlphabet),
    "customRandom": (()=>customRandom),
    "nanoid": (()=>nanoid),
    "random": (()=>random)
});
;
let random = (bytes)=>crypto.getRandomValues(new Uint8Array(bytes));
let customRandom = (alphabet, defaultSize, getRandom)=>{
    let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
    let step = -~(1.6 * mask * defaultSize / alphabet.length);
    return (size = defaultSize)=>{
        let id = '';
        while(true){
            let bytes = getRandom(step);
            let j = step;
            while(j--){
                id += alphabet[bytes[j] & mask] || '';
                if (id.length === size) return id;
            }
        }
    };
};
let customAlphabet = (alphabet, size = 21)=>customRandom(alphabet, size, random);
let nanoid = (size = 21)=>crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte)=>{
        byte &= 63;
        if (byte < 36) {
            id += byte.toString(36);
        } else if (byte < 62) {
            id += (byte - 26).toString(36).toUpperCase();
        } else if (byte > 62) {
            id += '-';
        } else {
            id += '_';
        }
        return id;
    }, '');
}}),
}]);

//# sourceMappingURL=node_modules_ffa4ff5d._.js.map